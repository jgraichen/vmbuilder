#!/bin/bash
#
#    Ubuntu Jeos image builder
#    Copyright (C) 2007  Canonical Ltd.
#
#    Authors: Soren Hansen <soren@canonical.com>
#             Neal McBurnett <neal@mcburnett.org>
#             Michael Vogt <michael.vogt@ubuntu.com>
#             Mike Frisch
#             Nick Barcet <nick.barcet@canonical.com>
#             Onno Benschop <onno@itmaze.com.au>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Todo:
#  create launchjeos command for vmware vm's
#  fix perl locale warnings
#  review security of running as root, messing with $DESTINATION

usage () {
	cat <<EOT
usage: ubuntu-jeos-builder  [--addpkg PKG]
                            [(-a|--arch) i386] 
                            [(-d|--dest) <destination (directory)>]
                            [--domain DOMAIN]
                            [-h|--help]
                            [--hostname NAME]
                            [--mem num]
                            [--mirror URL]
                            [--removepkg PKG]
                            [(-s|--suite) hardy]
                            [(-t|--tmp) temp_dir]
                            [--vm (vmw6|vmserver|vbox|qemu|kvm)]
                            [--user username]
                            [--name fullname]
                            [--pass password]
                            [--part partitionfile]
                            [--rootsize size]
                            [--no-opt]
                            [--optsize size]
                            [--swapsize size]
                            [--kernel-flavour <flavour>]
                            [--components <comma separated list of components>]
                            [--ssh-key <public key file>]
                            [--exec <script to execute>]
                            [--ip address [
                            [--mask value]
                            [--net value]
                            [--bcast value]
                            [--gw address]
                            [--dns address] ]

--addpkg PKG       Install PKG into the guest (can be specfied multiple times)
-a, --arch ARCH    Specify the target architecture. Valid options: i386*
-d, --dest         Specify the destination directory.
                   Default: ubuntu-jeos-$SUITE-$ARCH
--domain DOMAIN    Set DOMAIN as the domain name of the guest. Default:
                   The domain of the machine running this script.
-h, --help         This help text.
--hostname NAME    Set NAME as the hostname of the guest. Default: ubuntu
                   Also uses this name as the VM name
--mem NN           Assign NN megabytes of memory to the guest vm.
                   Default: 128
--mirror URL       Use Ubuntu mirror at URL instead of the default, which
                   is: http://archive.ubuntu.com/ubuntu
--removepkg PKG    Remove PKG from the guest (can be specfied multiple times)
-s, --suite SUITE  Use the specified Ubuntu suite. Valid options: hardy, gutsy,
                   feisty, dapper
-t, --tmp  TMPDIR  Use TMPDIR as temporary working area for the image
                   generation. Defaults to \$TMPDIR if set, or /tmp if not.
--vm VM            Generate image for specified virtualisation software.
                   Valid choices are: vmw6* vmserver vbox qemu kvm
--user username    Set the name of the user to be added. Default ubuntu.
--name fullname    Set the full name of the user to be added. Default Ubuntu.
--pass password    Set the password for the user. Default ubuntu.
--no-opt           Do not build the /opt image
--part partfile    Allows to specify a partition table in partfile
                   each line of partfile should specify (root first):
                      mountpoint size
                   where size is in megabytes. You can have up to 4 virtual disks,
                   a new disk starts on a line with ---
                   ie :
                      root 1000
                      /opt 1000
                      swap 256
                      ---
                      /var 2000
                      /log 1500
The following three option are not used if --part is specified:
--rootsize size    The size in meg of the root filesystem (default 1000)
--optsize size     The size in meg of the /opt filesystem (default 4000)
--swapsize size    The size in meg of the swap partition (default 1000)

--kernel-flavour   The kernel image flavour to install (default: virtual for
                   >=gutsy, server otherwise)
--components       A comma seperaed list of distro components to include 
                   (e.g. main,universe). This defaults to "main"
--ssh-key          Add the given ssh public key file (absolute path)
                   to root's authorized keys and install openssh-server
                   (WARNING: this has strong security implications)
--exec             Run the given script file. You can use 
                   'chroot root <cmd>' to execute code in the guest.
--ip address       Ip address in dotted form
                   (defaults to dhcp if not specified)

Options belows are discarded if --ip is not specified
--mask value       IP mask in dotted form (default: 255.255.255.0)
--net value        IP net address (default: X.X.X.0)
--bcast value      IP broadcast (default: X.X.X.255)
--gw address       Gateway address (default: X.X.X.1)
--dns address      Name server address (default: X.X.X.1)

('*' denotes default option)

ubuntu-jeos-builder is Copyright (C) 2007 Canonical Ltd. and
written by Soren Hansen <soren@canonical.com>
EOT
}

#
# The defaults
#
ARCH="i386"
if [ -z "$TMPDIR" ]
then
	TMPDIR="/tmp"
fi
VM=vmw6
USER=ubuntu
NAME=Ubuntu
PASS=ubuntu
SUITE="hardy"
MIRROR="http://archive.ubuntu.com/ubuntu"
MEM=128
HOSTNAME="ubuntu"
DOMAIN="`hostname -d`"
ROOTSIZE="1000"
OPTSIZE="4000"
SWAPSIZE="1000"
COMPS="main"
SSHKEY=""
OPTFS="yes"
declare -a MOUNTPOINTS 
declare -a MOUNTSIZES
declare -a MOUNTDISKS
declare -a DISKIMGS
declare -a DISKSIZES
declare -a PARTITION_START
declare -a PARTITION_END
letters=("a" "b" "c" "d")

TEMP=`getopt -o a:d:hs:t: --long addpkg:,arch:,dest:,domain:,help,hostname:,mem:,mirror:,removepkg:,suite:,tmp:,vm:,user:,name:,pass:,part:,rootsize:,swapsize:,optsize:,ip:,mask:,net:,bcast:,gw:,dns:,kernel-flavour:,components:,ssh-key:,no-opt,exec:,  -- "$@"`
eval set -- "$TEMP"

while true
do
	case "$1" in 
		--addpkg)
			echo "Will add $2 to the guest"
			PKGCMD="$PKGCMD $2"
			shift 2
		;;
		-a|--arch)
			if [ "$2" = i386 ] || [ "$2" = amd64 ]
			then
				echo "Setting architecture to \"$2\""
				ARCH="$2"
			else
				echo "Invalid architecture: \"$2\". Valid choices are: i386 amd64"
				exit 1
			fi
			shift 2
		;;
		-d|--dest)
			if [ -d "`dirname $2`" ]
			then
				if [ -w "`dirname $2`" ]
				then
					echo "Setting destination to \"$2\""
					if [ ! "${2#/}" = "${2}" ]
					then
						# Absolute path given
						DESTINATION="$2"
					else
						# Relative path given
						DESTINATION="${PWD}/$2"
					fi
				else
					echo "\"`dirname $2`\" is not writable"
					exit 1
				fi
			else
				echo "\"`dirname $2`\" is not a directory"
				exit 1
			fi
			shift 2
		;;
		--domain)
			echo "Setting guest domain to $2"
			DOMAIN="$2"
			shift 2
		;;
		-h|--help)
			usage
			exit 0
			;;
		--hostname)
			echo "Setting guest hostname to $2"
			HOSTNAME="$2"
			shift 2
		;;
		--mem)
			echo "Setting guest memory to $2 MB"
			MEM="$2"
			shift 2
		;;
		--mirror)
			echo "Setting Ubuntu mirror to \"$2\""
			MIRROR="$2"
			shift 2
		;;
		--removepkg)
			echo "Will remove $2 from the guest"
			PKGCMD="$PKGCMD ${2}-"
			shift 2
		;;
		--s|--suite)
			if [ "$2" = gutsy ] || [ "$2" = feisty ] || [ "$2" = dapper ] || [ "$2" = hardy ]
			then
				echo "Setting Ubuntu version to \"$2\""
				SUITE="$2"
			else
				echo "Invalid Ubuntu version: \"$2\". Valid choices are: hardy gutsy feisty dapper"
				exit 1
			fi
			shift 2
		;;
		-t|--tmp)
			if [ ! -d "$2" ]
			then
				echo "\"$2\" is not a directory"
				exit 1
			fi
			if [ ! -w "$2" ]
			then
				echo "\"$2\" is not writable"
				exit 1
			fi
			echo "Setting temporary working dir to \"$2\""
			TMPDIR="$2"
			shift 2
		;;
		--vm)
			if [ "$2" = vmw6 ] || [ "$2" = vmserver ] || [ "$2" = vbox ] || [ "$2" = qemu ] || [ "$2" = kvm ]
			then
				echo "Setting target vm to \"$2\""
				VM="$2"
			else
				echo "Invalid vm software: \"$2\". Valid choices are: vmw6 vmserver vbox qemu kvm"
				exit 1
			fi
			shift 2
		;;
		--user)
                        echo "Setting username to: \"$2\""
                        USER="$2"
                        shift 2
                ;;
                --name)
                        echo "Setting fullname to: \"$2\""
                        NAME="$2"
                        shift 2
                ;;
                --pass)
                        echo "Setting password to: \"$2\""
                        PASS="$2"
                        shift 2
                ;;
		--part)
			echo "Setting partitions from \"$2\""
			PARTFILE="$2"
			shift 2
		;;
		--rootsize)
		        echo "Setting rootsize to \"$2\""
			ROOTSIZE="$2"
			shift 2
		;;
		--swapsize)
                        echo "Setting swapsize to \"$2\""
                        SWAPSIZE="$2"
                        shift 2
                ;;
		--optsize)
                        echo "Setting optsize to \"$2\""
                        OPTSIZE="$2"
                        shift 2
                ;;
		--kernel-flavour)
		        echo "Setting kernel flavour to \"$2\""
			KERNEL_FLAVOUR="$2"
			shift 2
		;;
		--components)
		        echo "Setting compoents to \"$2\""
			COMPS="$2"
			shift 2
		;;
		--ssh-key)
		        echo "Setting ssh-key to \"$2\""
			SSHKEY="$2"
			shift 2
		;;
		--exec)
			echo "Setting exec script to \"$2\""
			EXEC="$2"
			shift 2
		;;
		--ip)
			echo "setting ipaddress to \"$2\""
			IP=$2
			shift 2
		;;
		--mask)
			echo "setting mask to \"$2\""
			MASK=$2
			shift 2
		;;
		--net)
			echo "setting network to \"$2\""
			NETWORK=$2
			shift 2
		;;
		--bcast)
			echo "setting broadcast to \"$2\""
			BCAST=$2
			shift 2
		;;
		--gw)
			echo "setting gateway to \"$2\""
			GW=$2
			shift 2
		;;
		--dns)
			echo "setting name server to \"$2\""
			DNS=$2
			shift 2
		;;
		--no-opt)
		        echo "Not building /opt"
			OPTFS="no"
			shift 1
		;;
		--)
			shift
			break
		;;
	esac
done

if [ $# -gt 0 ];
then
	usage
	exit 1
fi

if [ ! "`id -u`" = 0 ]
then
	echo "$0 must be run as root (e.g. by means of sudo)"
	exit 1
fi

if [ -z "$PARTFILE" ]; then
	let partstart=0
	let partid=0
	let NUMDISKS=0
	DISKIMGS[0]="root"

	MOUNTPOINTS[$partid]="root" 
	MOUNTDISKS[$partid]="a"
	if [ -z "$ROOTSIZE" ]; then
		MOUNTSIZES[$partid]="1000"
	else
		MOUNTSIZES[$partid]="$ROOTSIZE"
	fi
	let PARTITION_START[$partid]=$partstart
	let PARTITION_END[$partid]=$partstart+MOUNTSIZES[$partid]
	let partstart=PARTITION_END[$partid]+1

	if [ "$OPTFS" = "yes" ]
	then
		let partid=$partid+1
		MOUNTPOINTS[$partid]="/opt" 
			MOUNTDISKS[$partid]="a"
		if [ -z "$OPTSIZE" ]; then
			MOUNTSIZES[$partid]="4000"
		else
			MOUNTSIZES[$partid]="$OPTSIZE"
		fi
		let PARTITION_START[$partid]=$partstart
		let PARTITION_END[$partid]=$partstart+MOUNTSIZES[$partid]
		let partstart=PARTITION_END[$partid]+1
	fi

	let partid=$partid+1
	MOUNTPOINTS[$partid]="swap" 
	MOUNTDISKS[$partid]="a"
	if [ -z "$SWAPSIZE" ]; then
		MOUNTSIZES[$partid2]="1000"
	else
		MOUNTSIZES[$partid2]="$SWAPSIZE"
	fi
	let PARTITION_START[$partid2]=$partstart
	let PARTITION_END[$partid2]=$partstart+MOUNTSIZES[$partid2]
	let DISKSIZES[0]=PARTITION_END[$partid2]+1
else
	letters=("a" "b" "c" "d")
	let index=0
	let diskindex=0
	let partnum=0
	let partstart=0

	echo "Disks and partitions:"

	exec 10<$PARTFILE
	while read line<&10
	do
		if [ "$line" = "---" ]; then
			let DISKSIZES[$diskindex]=$partstart
			let diskindex=$diskindex+1
			let partstart=0
			let partnum=0
			if [ $diskindex -gt 3 ]; then
				echo "Sorry, no more than 4 IDE disks..."
				exit 1
			fi
		else
			MOUNTDISKS[$index]="${letters[$diskindex]}"
			MOUNTPOINTS[$index]=${line%\ *}
			MOUNTSIZES[$index]=`echo "${line#*\ }" | sed 's/^[ \t]*//'`
			let PARTITION_START[$index]=$partstart
			let PARTITION_END[$index]=$partstart+MOUNTSIZES[$index]
			if [ $partnum -eq 0 ]; then
				DISKIMGS[$diskindex]=`echo "${MOUNTPOINTS[$index]}" | sed 's%\/%%g' | sed 's/[ \t]*$//'`
				echo " Disk: $diskindex ${DISKIMGS[$diskindex]}"
			fi

			echo "  Partition: $partnum ${MOUNTPOINTS[$index]} start: $partstart end: ${PARTITION_END[$index]} size: ${MOUNTSIZES[$index]}"
			let partstart=PARTITION_END[$index]+1
			let index=$index+1
			let partnum=$partnum+1
			
		fi
	done 
	let DISKSIZES[$diskindex]=$partstart
	let NUMDISK=$diskindex
fi

WORKINGDIR=`mktemp -d -p $TMPDIR jeos-builder-XXXXXXXXXX` || exit 1

if [ -z "$DESTINATION" ]
then
        DESTINATION="$PWD/ubuntu-jeos-$SUITE-$ARCH"
fi

if [ -z "$KERNEL_FLAVOUR" ]
then
        if [ "$SUITE" = "gutsy" ] || [ "$SUITE" = "hardy" ]
        then
                KERNEL_FLAVOUR="virtual"
        else
                KERNEL_FLAVOUR="server"
        fi
fi

if [ -n "${SUDO_USER}" ]; then
        sudo -u "${SUDO_USER}" mkdir "${DESTINATION}"
else
        mkdir "${DESTINATION}"
fi

if [ $? -ne 0 ]; then
        echo "Error creating directory ${DESTINATION}. Unable to proceed."
	rm -rf $WORKINGDIR
        exit 1
fi

if [ -z "$IP" ]; then
	IP="DHCP"
else
	if [ -z "$MASK" ]; then
		MASK="255.255.255.0"
		echo "setting mask to \"$MASK\""
	fi
	if [ -z "$NET" ]; then
		NET=`echo $IP | sed 's/\./.0./3' | sed 's/\.[[:digit:]]\{1,3\}$//'` 
		echo "setting network to \"$NET\""
	fi
	if [ -z "$BCAST" ]; then
		BCAST=`echo $IP | sed 's/\./.255./3' | sed 's/\.[[:digit:]]\{1,3\}$//'` 
		echo "setting broadcast to \"$BCAST\""
	fi
	if [ -z "$GW" ]; then
                GW=`echo $IP | sed 's/\./.1./3' | sed 's/\.[[:digit:]]\{1,3\}$//'`
		echo "setting gateway to \"$GW\""
        fi
	if [ -z "$DNS" ]; then
                DNS=`echo $IP | sed 's/\./.1./3' | sed 's/\.[[:digit:]]\{1,3\}$//'`
		echo "setting name server to \"$DNS\""
        fi


fi 

do_initial_user () {
	#
	# Set up a user with sudo etc.
	#

	chroot root adduser --disabled-password --gecos "${NAME}" ${USER} > /dev/null
	chroot root chpasswd <<EOF
${USER}:${PASS}
EOF

	chroot root addgroup --system admin >/dev/null 2>&1
	chroot root adduser ${USER} admin >/dev/null 2>&1

	cat >> root/etc/sudoers << EOF

# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL
EOF

	for group in adm audio cdrom dialout floppy video plugdev dip netdev powerdev lpadmin scanner; do
		chroot root adduser ${USER} $group >/dev/null 2>&1
	done

}

do_network_setup () {
	echo $HOSTNAME > root/etc/hostname

	cat > root/etc/hosts <<EOF
127.0.0.1 localhost
127.0.1.1 $HOSTNAME.$DOMAIN $HOSTNAME
EOF

	cat > root/etc/network/interfaces <<EOF
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
EOF
	if [ "$IP" = "DHCP" ]; then
		cat >> root/etc/network/interfaces <<EOF
iface eth0 inet dhcp
EOF
	else
		cat >> root/etc/network/interfaces <<EOF
iface eth0 inet static
        address $IP
        netmask $MASK 
        network $NET
        broadcast $BCAST
        gateway $GW
        # dns-* options are implemented by the resolvconf package, if installed
        dns-nameservers $DNS
        dns-search $DOMAIN
EOF
	fi

	#temporary fix for /var/run/network not being created
	if [ ! -e root/var/run/network ]; then 
		echo "Creating /var/run/network"
		mkdir root/var/run/network
	fi
}

do_bootloader () {
        updategrub="\/usr\/sbin\/update-grub"
	if [ "$SUITE" = dapper ]
	then
	    updategrub="\/sbin\/update-grub"
	fi
	sed -e "s/%UPDATEGRUB%/$updategrub/g" << EOF | cat > root/etc/kernel-img.conf
do_symlinks = yes
relative_links = yes
do_bootfloppy = no
do_initrd = yes
link_in_boot = no
postinst_hook = %UPDATEGRUB%
postrm_hook = %UPDATEGRUB%
do_bootloader = no
EOF

	chroot root apt-get --force-yes -y install grub


	mkdir root/boot/grub
	#
	# Create device.map
	#
	cat > root/boot/grub/device.map << EOF
(fd0)	/dev/fd0
EOF
	if [ "$SUITE" = dapper ]
        then
		echo "(hd0) /dev/sd${letters[0]}" >> root/boot/grub/device.map
	else
		echo "(hd0) UUID=$(cat ${MOUNTPOINTS[0]}.uuid)" >> root/boot/grub/device.map
	fi

	if [ $ARCH = "amd64" ]
	then
		grubarch="x86_64-pc"
	else
		grubarch="i386-pc"
	fi
	#
	# No animals (and only one human) were harmed during the making of the following boot loader installation.
	#

	# This should replicate pretty closely what grub's stage2 shell does when asked to install
	BOOTSEC_BPB_OFFSET=$((0x3))
	BOOTSEC_BPB_LENGTH=$((0x3B))
	STAGE1_WINDOWS_NT_MAGIC=$((0x1b8))
	STAGE1_PARTEND=$((0x1fe))
	STAGE1_BOOT_DRIVE=$((0x40))
	STAGE1_BOOT_DRIVE_CHECK=$((0x4b))
	STAGE1_STAGE2_SECTOR=$((0x44))
	STAGE1_STAGE2_ADDRESS=$((0x42))
	STAGE1_STAGE2_SEGMENT=$((0x48))
	STAGE2_FORCE_LBA=$((0x11))
	STAGE2_VER_STR_OFFS=$((0x12))

	# *sigh* dapper is a bit special
	grubroot=root/usr/lib/grub/
	updategrub=/usr/sbin/update-grub
	if [ "$SUITE" = dapper ]
	then
	    grubroot=root/lib/grub
	    updategrub=/sbin/update-grub
	fi
	cp $grubroot/$grubarch/stage1 stage1_buffer
	dd bs=512 count=1 if=root.raw of=old_sect

	dd bs=1 count=$BOOTSEC_BPB_LENGTH conv=notrunc skip=$BOOTSEC_BPB_OFFSET seek=$BOOTSEC_BPB_OFFSET if=old_sect of=stage1_buffer
	dd bs=1 count=$(($STAGE1_PARTEND - $STAGE1_WINDOWS_NT_MAGIC)) conv=notrunc skip=$STAGE1_WINDOWS_NT_MAGIC seek=$STAGE1_WINDOWS_NT_MAGIC if=old_sect of=stage1_buffer

	# Set boot device to GRUB_UNKNOWN_DEVICE (that's what grub does) and force lba
	/bin/echo -ne '\xff\01' | dd bs=1 count=2 conv=notrunc seek=$STAGE1_BOOT_DRIVE of=stage1_buffer

	# Hack to workaround buggy bios'es
	/bin/echo -ne '\x90\x90' | dd bs=1 count=2 conv=notrunc seek=$STAGE1_BOOT_DRIVE_CHECK of=stage1_buffer

	dd if=$grubroot/$grubarch/e2fs_stage1_5 of=stage2_first_buffer bs=512 count=1
	dd if=$grubroot/$grubarch/e2fs_stage1_5 of=stage2_second_buffer bs=512 count=1 skip=1

	# Stage 2 (actually 1.5) is at sector 1 (0-indexed)
	/bin/echo -ne '\1\0\0\0' | dd bs=1 count=4 conv=notrunc seek=$STAGE1_STAGE2_SECTOR of=stage1_buffer
	# Set address and segment accordingly
	/bin/echo -ne '\0\x20' | dd bs=1 count=2 conv=notrunc seek=$STAGE1_STAGE2_ADDRESS of=stage1_buffer
	/bin/echo -ne '\0\02' | dd bs=1 count=2 conv=notrunc seek=$STAGE1_STAGE2_SEGMENT of=stage1_buffer

	/bin/echo -ne '\1' | dd bs=1 count=1 conv=notrunc seek=$STAGE2_FORCE_LBA of=stage2_second_buffer

	# These two are unexplained.. 
	/bin/echo -ne '\x10' | dd bs=1 count=1 conv=notrunc seek=508 of=stage2_first_buffer
	/bin/echo -ne '\0' | dd bs=1 count=1 conv=notrunc seek=$((0x19)) of=stage2_second_buffer

	# I couldn't figure out how to reimplement this properly in posix shell, so I'll hardcode the offset for now

	/bin/echo -ne ' /boot/grub/menu.lst\0' | dd bs=1 count=21 conv=notrunc seek=$((0x2c)) of=stage2_second_buffer

	#
	# Stuff this all back into the disk image
	#
	dd bs=512 count=1               if=stage1_buffer                              conv=notrunc of=root.raw
	dd bs=512 count=1 seek=1        if=stage2_first_buffer                        conv=notrunc of=root.raw
	dd bs=512 count=1 seek=2        if=stage2_second_buffer                       conv=notrunc of=root.raw
	dd bs=512         seek=3 skip=2 if=$grubroot/$grubarch/e2fs_stage1_5 conv=notrunc of=root.raw

	cp $grubroot/$grubarch/* root/boot/grub/

	# Hacky-di-hack.. First generate the template, then remove the errant kopt_2_6 (which hardcodes the root device to /dev/hda1) and then rerun update-grub.
	chroot root $updategrub -y
	if [ "$SUITE" = dapper ]; then
		sed -ie '/^# kopt_2_6/ d' root/boot/grub/menu.lst
	else
		rep="UUID=$(cat ${MOUNTPOINTS[0]}.uuid)"
		sed -ie "s/\/dev\/hda1/$rep/g" root/boot/grub/menu.lst
	fi
	chroot root $updategrub
	chroot root grub-set-default 0
	rm old_sect stage1_buffer stage2_first_buffer stage2_second_buffer
}

do_disk_images() {
	#
	# Create disk images, partitions and format
	#

	for ((i=0; i<${#DISKIMGS[@]}; i++)); do
		# create disk image
		let size=${DISKSIZES[$i]}*1024
		qemu-img create -f raw ${DISKIMGS[$i]}.raw $size

		# label the disk
		parted --script ${DISKIMGS[$i]}.raw mklabel msdos
	done
	
	let diskindex=-1
	curdisk=""

	# create the partitions
	for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
		if [ "$curdisk" != "${MOUNTDISKS[$i]i}" ]; then
			let diskindex++
			img="${DISKIMGS[$diskindex]}"
			curdisk=${MOUNTDISKS[$i]}
			echo "Disk: $curdisk $img"
		fi

		# Create partition and format
		echo "  creating partition ${MOUNTPOINTS[$i]} on $img"
		if [ "${MOUNTPOINTS[$i]}" = "swap" ]; then
			parted --script -- $img.raw mkpartfs primary linux-swap ${PARTITION_START[$i]} ${PARTITION_END[$i]}
		else
			parted --script -- $img.raw mkpartfs primary ext2 ${PARTITION_START[$i]} ${PARTITION_END[$i]}
		fi
	done
	
	#mount the disk loops
	for ((i=0;i<${#DISKIMGS[@]};i++)); do
		kpartx -av ${DISKIMGS[$i]}.raw
	done
	
	#format the partitions
	let diskindex=-1
        curdisk=""
        for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
                if [ "$curdisk" != "${MOUNTDISKS[$i]}" ]; then
                        let diskindex++
                        img="${DISKIMGS[$diskindex]}"
                        curdisk=${MOUNTDISKS[$i]}
			let partindex=1
                fi
		if  [ "${MOUNTPOINTS[$i]}" = "swap" ]; then
			echo formating /dev/mapper/loop${diskindex}p${partindex} as swap for ${MOUNTPOINTS[$i]}
			mkswap /dev/mapper/loop${diskindex}p${partindex}	
		else 
			echo formating /dev/mapper/loop${diskindex}p${partindex} as ext3 for ${MOUNTPOINTS[$i]}
			mkfs.ext3 /dev/mapper/loop${diskindex}p${partindex}
		fi
		/lib/udev/vol_id --uuid  /dev/mapper/loop${diskindex}p${partindex} >  ${MOUNTPOINTS[$i]}.uuid
		let partindex++
	done

}

do_debootstrap() {
	mkdir root
	debootstrap --components="$COMPS" --arch $ARCH $SUITE root "$MIRROR"
}

do_fstab_dapper() {
	#
	# Set up fstab
	#
        cat > root/etc/fstab << EOF
# /etc/fstab: static file system information.
#
# <file system>					<mount point>	<type>	<options>	<dump>	<pass>
proc						/proc		proc	defaults	0	0
EOF
	for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
		if [ "${MOUNTPOINTS[$i]}" = "root" ]; then
			echo "/dev/hd${MOUNTDISKS[$i]}1	/	ext3	defaults	0	1">>root/etc/fstab
		elif [ "${MOUNTPOINTS[$i]}" = "swap" ]; then
			echo "/dev/hd${MOUNTDISKS[$i]}1	swap      swap    defaults        0       1">>root/etc/fstab
		else 
			echo "/dev/hd${MOUNTDISKS[$i]}1	${MOUNTPOINTS[$i]}       ext3    defaults        0       1">>root/etc/fstab
		fi
	done
}

do_fstab() {
	#
	# Set up fstab
	#
	cat > root/etc/fstab << EOF
# /etc/fstab: static file system information.
#
# <file system>                                 <mount point>   <type>  <options>       <dump>  <pass>
proc                                            /proc           proc    defaults        0       0
EOF
	for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
                if [ "${MOUNTPOINTS[$i]}" = "root" ]; then
                        echo "UUID=$(cat ${MOUNTPOINTS[$i]}.uuid) /       ext3    defaults        0       1">>root/etc/fstab
                elif [ "${MOUNTPOINTS[$i]}" = "swap" ]; then
                        echo "UUID=$(cat ${MOUNTPOINTS[$i]}.uuid) swap      swap    defaults        0       1">>root/etc/fstab
                else
                        echo "UUID=$(cat ${MOUNTPOINTS[$i]}.uuid) ${MOUNTPOINTS[$i]}       ext3    defaults        0       1">>root/etc/fstab
                fi
        done
}

do_kernel_n_friends () {

	PKGS="linux-$KERNEL_FLAVOUR"
	if [ "$SUITE" != dapper ]
	then
		PKGS="$PKGS usplash usplash-theme-ubuntu"
	fi
	chroot root apt-get --force-yes -y install $PKGS
}

do_add_remove_packages () {
	cmd="apt-get --purge install "
	chroot root apt-get --purge install $PKGCMD
}

do_add_ssh_key () {
        if [ -z "$SSHKEY" ]
	then
	    return
	fi
	if [ ! -f "$SSHKEY" ]
	then
	    echo "NO $SSHKEY found"
	    return
	fi
	# we have a key, add it
	chroot root apt-get install --force-yes -y openssh-server
	mkdir root/root/.ssh
	cp "$SSHKEY" root/root/.ssh/authorized_keys
}

do_exec_script () {
       if [ ! -f "$EXEC" ]
       then
           echo "Script '$EXEC' not found."
           return
       fi
       #
       # Execute the script.
       #
       "$EXEC"
}

mount_parts () {
	base="$1"
	if [ "$base" = "" ]; then
		echo base is empty....  exiting
		exit 0
	fi
	let diskindex=-1
        curdisk=""
        for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
                if [ "$curdisk" != "${MOUNTDISKS[$i]}" ]; then
                        let diskindex++
                        img="${DISKIMGS[$diskindex]}"
                        curdisk=${MOUNTDISKS[$i]}
                        let partindex=1
                fi

                if  [ "${MOUNTPOINTS[$i]}" = "root" ]; then
			mount /dev/mapper/loop${diskindex}p${partindex} $base
		elif  [ "${MOUNTPOINTS[$i]}" != "swap" ]; then
			mkdir $base${MOUNTPOINTS[$i]}
			mount /dev/mapper/loop${diskindex}p${partindex} $base${MOUNTPOINTS[$i]}
                fi
		let partindex++
        done
}

umount_parts () {
	base="$1"
        for ((i=${#MOUNTPOINTS[@]};i>-1;i--)); do
                if  [ "${MOUNTPOINTS[$i]}" = "root" ]; then
                        umount  $base
                elif  [ "${MOUNTPOINTS[$i]}" != "swap" ]; then
                        umount  $base${MOUNTPOINTS[$i]}
                fi
        done
}

do_copy_to_disk_images () {

	chroot root apt-get clean
	#
	# Copy the debootstrapped filesystem into the partitions
	#
	mkdir target 
	#mount -o loop,offset=16384 root.raw target
	mount_parts target
	echo Copy the debootstrapped filesystem 
	cp -a root/* target
	umount_parts target
	rmdir target
	rm -rf root
}

do_target_vm_conversion () {
	echo Convert to format $VM

	if [ $VM = vmserver ]
	then
		QEMU_IMG_CONVERT_OPTS="-O vmdk"
		VMHWVERSION=4
	elif [ $VM = vmw6 ]
	then
		QEMU_IMG_CONVERT_OPTS="-O vmdk -6"
		VMHWVERSION=6
	fi

	if [ $ARCH = "amd64" ]
	then
		guestos="ubuntu-64"
	else
		guestos="ubuntu"
	fi

	if [ "$VM" = vmserver ] || [ "$VM" = vmw6 ]
	then
		QEMU_IMG_CONVERT_EXTENSION=".vmdk"
		cat > $HOSTNAME.vmx << EOF
config.version = "8"
virtualHW.version = "$VMHWVERSION"
scsi0.present = "FALSE"
scsi0.virtualDev = "lsilogic"
memsize = "$MEM"
Ethernet0.virtualDev = "vlance"
Ethernet0.present = "TRUE"
Ethernet0.connectionType = "bridged"
displayName = "$HOSTNAME $ARCH"
guestOS = "$guestos"
priority.grabbed = "normal"
priority.ungrabbed = "normal"
powerType.powerOff = "hard"
powerType.powerOn = "hard"
powerType.suspend = "hard"
powerType.reset = "hard"
floppy0.present = "FALSE"

EOF

		chmod +x $HOSTNAME.vmx
		FILES="$HOSTNAME.vmx"
		for ((i=0;i<${#DISKIMGS[@]};i++)); do
			FILES="$FILES ${DISKIMGS[$i]}.vmdk"
			let "id=$i%2"
			let "bus=$i/2"
			echo "ide${bus}:${id}.present = \"TRUE\"">>$HOSTNAME.vmx
			echo "ide${bus}:${id}.fileName = \"${DISKIMGS[$i]}.vmdk\"">>$HOSTNAME.vmx
		done

	elif [ $VM = qemu ] || [ $VM = kvm ]
	then
		QEMU_IMG_CONVERT_OPTS="-O qcow2 -6"
		QEMU_IMG_CONVERT_EXTENSION=".qcow2"
		if [ $VM = kvm ]
		then
			CMD=kvm
		else
			CMD=qemu
		fi
		FILES="$HOSTNAME.$CMD" 
		IMGFILES=""
		let diskindex=1
		curdisk=""
		for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
			if [ "$curdisk" != "${MOUNTDISKS[$i]}" ]; then
                        	let diskindex++
        	                img="${DISKIMGS[$diskindex]}"
                	        curdisk=${MOUNTDISKS[$i]}
                		FILES="$FILES $img.qcow2"
				IMGFILES="$IMGFILES -hd$curdisk $img.qcow2" 
			fi
		done

        cat > $HOSTNAME.$CMD <<EOF
#!/bin/sh
$CMD -m $MEM $IMGFILES "\$@"
EOF
		chmod +x $HOSTNAME.$CMD
	fi

	for ((i=0;i<${#DISKIMGS[@]};i++)); do
		qemu-img convert $QEMU_IMG_CONVERT_OPTS ${DISKIMGS[$i]}.raw "${DISKIMGS[$i]}${QEMU_IMG_CONVERT_EXTENSION}"
	done

	test -n "${SUDO_USER}" && chown "$SUDO_USER" $FILES
	mv $FILES $DESTINATION
	echo "Done.  Images are in ${DESTINATION}."
}

do_cleanup () {
	#unmount the disk loops
        for ((i=0;i<${#DISKIMGS[@]};i++)); do
                kpartx -dv ${DISKIMGS[$i]}.raw
        done

	for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
		rm ${MOUNTPOINTS[$i]}.uuid
	done
	for ((i=0;i<${#DISKIMGS[@]};i++)); do
                rm ${DISKIMGS[$i]}.raw 
        done
	cd /
	rm -rf "$WORKINGDIR"
}

cd "$WORKINGDIR"

do_disk_images
do_debootstrap
if [ "$SUITE" = dapper ]
then
    do_fstab_dapper
else
    do_fstab
fi
do_initial_user
do_network_setup
do_bootloader
do_kernel_n_friends 
do_add_remove_packages
do_add_ssh_key
do_exec_script
do_copy_to_disk_images 
do_target_vm_conversion 
do_cleanup

exit 0
