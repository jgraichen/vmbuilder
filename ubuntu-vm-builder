#!/bin/bash
#
#    Ubuntu Jeos image builder
#    Copyright (C) 2007-2008 Canonical Ltd.
#
#    Authors: Soren Hansen <soren@canonical.com>
#             Neal McBurnett <neal@mcburnett.org>
#             Michael Vogt <michael.vogt@ubuntu.com>
#             Mike Frisch
#             Nick Barcet <nick.barcet@ubuntu.com>
#             Onno Benschop <onno@itmaze.com.au>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Todo:
#  create launchjeos command for vmware vm's
#  review security of running as root, messing with $DESTINATION

test -n "$TMPDIR" || TMPDIR=""
# make sure variables are initialized and script quits when error are encountered
set -o nounset
set -o errexit

# display debug info
VERBOSE=""
info () {
    if [ -n "$VERBOSE" ]; then
        echo "$@"
    fi
}

# Keep perl inside the chroot quiet
HOSTLANG=$LANG
LANG=C

# array to hold list of raw "files" to use
declare -a RAW
declare -i NUMRAW
let NUMRAW=0 || true

usage () {
	cat <<EOT
usage: ubuntu-vm-builder <vm> <suite>   
                            [--addpkg PKG]
                            [(-a|--arch) [(amd64|i386|lpia]]
                            [(-d|--dest) <destination (directory)>]
                            [(-o|--overwrite)]
                            [-c PATH]
                            [--domain DOMAIN]
                            [-h|--help]
                            [--hostname NAME]
                            [--mem num]
                            [--mirror URL]
                            [--security-mirror URL]
                            [--removepkg PKG]
                            [(-t|--tmp) temp_dir]
                            [--tmpfs options]
                            [--user username]
                            [--name fullname]
                            [--pass password]
                            [--raw path]
                            [--part partitionfile]
                            [--rootsize size]
                            [--optsize size]
                            [--swapsize size]
                            [--kernel-flavour <flavour>]
                            [--components <comma separated list of components>]
                            [--ssh-key <public key file>]
                            [--ssh-user-key <public key file>]
                            [--exec <script to execute>]
                            [--firstboot <script to execute>]
                            [--firstlogin <script to execute>]
                            [--ip address [
                            [--mask value]
                            [--net value]
                            [--bcast value]
                            [--gw address]
                            [--dns address] ]

vm                 Generate image for the specified virtualisation software.
                   Valid choices are: vmw6 vmserver vbox qemu kvm
suite              Use the specified Ubuntu suite.
                   Valid options: intrepid, intrepid, hardy, gutsy, feisty, edgy, dapper
--addpkg PKG       Install PKG into the guest (can be specfied multiple times)
-a, --arch ARCH    Specify the target architecture.
                   Valid options: amd64 i386 lpia (defaults to host arch)
-d, --dest         Specify the destination directory.
                   Default: ubuntu-vm-<SUITE>-<ARCH>-<HOSTNAME>
-o, --overwrite    Force overwrite of destination directory if it already exist
-c PATH            Specify a optional configuration file (default: ~/.ubuntu-vm-builder)
--domain DOMAIN    Set DOMAIN as the domain name of the guest. Default:
                   The domain of the machine running this script.
-h, --help         This help text.
-v, --verbose      Show a lot of information as the vm is generated.
--hostname NAME    Set NAME as the hostname of the guest. Default: ubuntu
                   Also uses this name as the VM name
--mem NN           Assign NN megabytes of memory to the guest vm.
                   Default: 128
--mirror URL       Use Ubuntu mirror at URL instead of the default, which
                   is http://archive.ubuntu.com/ubuntu for official arches
                   and http://ports.ubuntu.com/ubuntu-ports otherwise
--security-mirror URL
                   Use Ubuntu security mirror at URL instead of the default,
                   which is http://security.ubuntu.com/ubuntu for official
                   arches and http://ports.ubuntu.com/ubuntu-ports otherwise
--iso PATH         Use an iso image as the source for installation of file.
                   Full path to the iso must be provided. If --mirror is also
		   provided, it will be used in the final sources.list of the vm.
                   This requires suite and kernel parameter to match what is 
		   available on the iso, obviously.
--removepkg PKG    Remove PKG from the guest (can be specfied multiple times)
-t, --tmp  TMPDIR  Use TMPDIR as temporary working area for the image
                   generation. Defaults \$TMPDIR if it is defined, or /tmp otherwise.
                   If it is set to "-", working data will go in same directory as -d 
                   if specified with a full path or the current directory if not.
--tmpfs OPTIONS    Use a tmpfs as the working directory, specifying its size or
                   "-" to use tmpfs default (suid,dev,size=1G).
--user USERNAME    Set the name of the user to be added. Default: ubuntu.
--name FULLNAME    Set the full name of the user to be added. Default: Ubuntu.
--pass PASSWORD    Set the password for the user. Default: ubuntu.
--raw PATH         Specify a raw file or device to install in.  Can be specified
                   multiple time in conjunction with --part, paths will be used in
                   the order presented. In any case you are to insure that the raw
                   element(s) specified have enough free space.
--part PATH        Allows to specify a partition table in partfile pointed by PATH
                   each line of partfile should specify (root first):
                      mountpoint size
                   where size is in megabytes. You can have up to 4 virtual
				   disks, a new disk starts on a line with ---
                   ie :
                      root 1000
                      /opt 1000
                      swap 256
                      ---
                      /var 2000
                      /log 1500
The following three options are not used if --part is specified:
--rootsize SIZE    The size in MB of the root filesystem (default 4096)
--optsize SIZE     The size in MB of the /opt filesystem. If not set, no /opt
                   filesystem will be added.
--swapsize SIZE    The size in MB of the swap partition (default 1024)
--kernel-flavour FLAVOUR
                   The kernel image flavour to install (default: virtual for
                   >= gutsy on i386, lpia on lpia, server otherwise)
--components COMP  A comma seperated list of distro components to include
                   (e.g. main,universe). This defaults to "main"
--ssh-key PATH     Add the given ssh public key file (absolute path)
                   to root's authorized keys and install openssh-server
--in-place         Install directly into the filesystem images. This is needed
                   if your \$TMPDIR is nodev and/or nosuid, but will result in
                   slightly larger file system images.
                   (WARNING: this has strong security implications)
--ssh-user-key PATH 
                   Add the given ssh key file (absolute path)
		   to the user's authorized key and install openssh-server.
--exec PATH        Run the given script file. You can use 
                   'chroot root <cmd>' to execute code in the guest.
                   See 'man ubuntu-vm-builder' for more explanations
--firstboot PATH   Specify a script that will be copied into the guest and
                   executed the first time the machine boots.  This script
                   must not be interactive.
--firstlogin PATH  Specify a script that will be copied into the guest and
                   will be executed the first time the user logs in. This
                   script can be interactive.
--ip ADDRESS       Ip address in dotted form
                   (defaults to dhcp if not specified)

Options below are discarded if --ip is not specified
--mask VALUE       IP mask in dotted form (default: 255.255.255.0)
--net VALUE        IP net address (default: X.X.X.0)
--bcast VALUE      IP broadcast (default: X.X.X.255)
--gw ADDRESS       Gateway address (default: X.X.X.1)
--dns ADDRESS      Name server address (default: X.X.X.1)

('*' denotes default option)

EOT

	#
	# Emit usage info specific to each vm type
	#
	for vm in /usr/share/ubuntu-vm-builder/vms/*
	do
		vm="`basename "$vm"`"
		echo "Options specific for vm type $vm:"
		/usr/share/ubuntu-vm-builder/vms/$vm usage
	done

cat <<EOT

ubuntu-vm-builder is Copyright (C) 2007-2008 Canonical Ltd. and
written by Soren Hansen <soren@canonical.com>.
EOT
}

if [ ! "`id -u`" = 0 ]
then
        echo "$0 must be run as root (e.g. by means of sudo)"
        exit 1
fi

if [ $# -lt 2 ]
then
	echo "Please specify vm and suite"
	usage
	exit 1
fi

#
# Import a stack of sanity checks
#
. /usr/share/ubuntu-vm-builder/sanity-checks

#
# First arg is the vm tech to use
#
check_vm "$1"
VM="$1"
. /usr/share/ubuntu-vm-builder/vms/$VM
shift

#
# Second arg is the Ubuntu suite to install
#
check_suite "$1"
SUITE="$1"
. /usr/share/ubuntu-vm-builder/suites/$SUITE
shift

# read default config from ~/.ubuntu-vm-builder and initialize variables
. /usr/share/ubuntu-vm-builder/config-handler

set +e; trap "usage;exit 1" ERR
TEMP=`getopt -o a:d:ohs:t:vc: --long addpkg:,arch:,dest:,overwrite,domain:,help,hostname:,mem:,mirror:,security-mirror:,iso:,removepkg:,suite:,tmp:,tmpfs:,vm:,user:,name:,pass:,part:,rootsize:,swapsize:,optsize:,raw:,ip:,mask:,net:,bcast:,gw:,dns:,kernel-flavour:,components:,ssh-key:,ssh-user-key:,no-opt,exec:,firstboot:,firstlogin:,verbose,in-place,$vm_getopt_args  -- "$@"` 
trap - ERR; set -e
eval set -- "$TEMP"

while true
do
	case "$1" in 
		--addpkg)
			PKGCMD="$PKGCMD $2"
			shift 2
		;;
		-a|--arch)
			validate_arch $2
			ARCH="$2"
			shift 2
		;;
		-d|--dest)
			check_dest_dir "$2"
			if [ ! "${2#/}" = "${2}" ]
			then
				# Absolute path given
				DESTINATION="$2"
			else
				# Relative path given
				DESTINATION="${PWD}/$2"
			fi
			shift 2
		;;
		-o|--overwrite)
			OVERWRITE="YES"
			shift 1
		;;
		--domain)
			DOMAIN="$2"
			shift 2
		;;
		--hostname)
			VMHOSTNAME="$2"
			shift 2
		;;
		--mem)
			MEM="$2"
			shift 2
		;;
		--mirror)
			MIRROR="$2"
			shift 2
		;;
		--security-mirror)
			SECURITY_MIRROR="$2"
			shift 2
		;;
		--iso)
			ISO="$2"
			shift 2
		;;
		--removepkg)
			PKGCMD="$PKGCMD ${2}-"
			shift 2
		;;
		-t|--tmp)
			VMTMPDIR="$2"
			shift 2
		;;
		--tmpfs)
			TMPFS="$2"
			shift 2
		;;
		--vm)
			check_vm "$2"
			shift 2
		;;
		--user)
			VMUSER="$2"
			shift 2
		;;
		--name)
			NAME="$2"
			shift 2
		;;
		--pass)
			PASS="$2"
   			shift 2
		;;
		--part)
			PARTFILE="$2"
			shift 2
		;;
		--rootsize)
			ROOTSIZE="$2"
			shift 2
		;;
		--swapsize)
			SWAPSIZE="$2"
			shift 2
		;;
		--optsize)
			OPTSIZE="$2"
			shift 2
		;;
		--raw)
			RAW[$NUMRAW]="$2"
			let NUMRAW=NUMRAW+1 
			shift 2
		;;
		--kernel-flavour)
			KERNEL_FLAVOUR="$2"
			shift 2
		;;
		--components)
			COMPS="$2"
			shift 2
		;;
		--ssh-key)
			SSHKEY="$2"
			shift 2
		;;
		--ssh-user-key)
			SSHUKEY="$2"
			shift 2
		;;
		--exec)
			EXEC="$2"
			shift 2
		;;
		--firstboot)
			FIRSTBOOT="$2"
			shift 2
		;;
		--firstlogin)
			FIRSTLOGIN="$2"
			shift 2
		;;
		--ip)
			IP="$2"
			shift 2
		;;
		--mask)
			MASK="$2"
			shift 2
		;;
		--net)
			NET="$2"
			shift 2
		;;
		--bcast)
			BCAST="$2"
			shift 2
		;;
		--gw)
			GW=$2
			shift 2
		;;
		--dns)
			DNS=$2
			shift 2
		;;
		--no-opt)
			echo "Ignored obsolete --no-opt option"
			shift 1
		;;
		-v|--verbose)
			VERBOSE="YES"
			shift 1
		;;
		-c)
			# already handled in config-handler
			shift 2
		;;
		--in-place)
			INSTALL_IN_PLACE="YEAH"
			shift 1
		;;
		--)
			shift
			break
		;;
		*)	
			argsused=0
			vm_getopt "$@" || true
			if [ $argsused -gt 0 ]
			then
				shift $argsused
			else
				# This code will never be used as getopt will have caught it
				# The vm had no clue what this was either
				echo "Unknown option: $1"
				usage
				exit 1
			fi
		;;
	esac
done

info "suite: $SUITE"
info "vm: $VM"

if [ -z "$ARCH" ]
then
	ARCH=`dpkg --print-architecture`
fi

if [ -z "$KERNEL_FLAVOUR" ]
then
	default_kernel
else
	check_kernel_flavour "$KERNEL_FLAVOUR"
fi
info "kernel: $KERNEL_FLAVOUR"

if [ -n "$VMTMPDIR" ]
then
	if [ "$VMTMPDIR" = "-" ]; then
		if [ ! "${DESTINATION#/}" = "${DESTINATION}" ]; then
			VMTMPDIR=$(dirname $DESTINATION)
		else
			VMTMPDIR="${PWD}"
		fi
	fi
else
	if [ -n "$TMPDIR" ]; then
		VMTMPDIR=$TMPDIR
	else
		VMTMPDIR="/tmp"
	fi
fi

TEMPLATEDIR=${TEMPLATEDIR:-/usr/share/ubuntu-vm-builder/templates}
LIBVIRT=${LIBVIRT:-}
VMUSER=${VMUSER:-"ubuntu"}
NAME=${NAME:-"ubuntu"}
PASS=${PASS:-"ubuntu"}

if [ -z "$MIRROR" ]
then
	if [ "$ARCH" = "lpia" ]
	then
		MIRROR="http://ports.ubuntu.com/ubuntu-ports"
	else
		MIRROR="http://archive.ubuntu.com/ubuntu"
	fi
fi
if [ -z "$SECURITY_MIRROR" ]
then
	if [ "$ARCH" = "lpia" ]
	then
		SECURITY_MIRROR="http://ports.ubuntu.com/ubuntu-ports"
	else
		SECURITY_MIRROR="http://security.ubuntu.com/ubuntu"
	fi
fi
# save the mirror value for the source list if we are using --iso
ORIGMIRROR=$MIRROR

MEM=${MEM:-"128"}
VMHOSTNAME=${VMHOSTNAME:-"ubuntu-vm-$SUITE-$ARCH"}
DOMAIN=${DOMAIN:-"`hostname -d`"}
DOMAIN=${DOMAIN:-"localdomain"}
ROOTSIZE=${ROOTSIZE:-"4096"}
SWAPSIZE=${SWAPSIZE:-"1024"}
if [ -z "$COMPS" ]
then
	if [ "$KERNEL_FLAVOUR" = "virtual" ]
	then
		COMPS="main"
	else
		COMPS="main,restricted"
	fi
fi

declare -a MOUNTPOINTS 
declare -a MOUNTSIZES
declare -a MOUNTDISKS
declare -a DISKIMGS
declare -a DISKSIZES
declare -a PARTITION_START
declare -a PARTITION_END

if [ $# -gt 0 ];
then
	usage
	echo 
	echo "Excess option(s): $@"
	exit 1
fi

# DISKIMGS holds the base names of the disk image files.
# LOOPDEV[i] holds the loop device name for disk image i
# MOUNTPOINTS[i] holds the mountpoint of partition i.
# MOUNTDISKS[i] holds
# MOUNTSIZES[i] holds the size of partition i.
info "Disk"

partstart=""
partid=""
NUMDISKS=""
letters=("a" "b" "c" "d")

set +e
if [ -z "$PARTFILE" ]; then
	let partstart=0 
	let partid=0 
	let NUMDISKS=0 
	if [ $NUMRAW -gt 0 ]; then
		DISKIMGS[0]=${RAW[0]}
	else
		DISKIMGS[0]="root.raw"
	fi
	
	MOUNTPOINTS[$partid]="root" 
	MOUNTDISKS[$partid]="a"
	MOUNTSIZES[$partid]="$ROOTSIZE"
	let PARTITION_START[$partid]=$partstart
	let PARTITION_END[$partid]=$partstart+MOUNTSIZES[$partid]
	let partstart=PARTITION_END[$partid]+1

	if [ -n "$OPTSIZE" ]
	then
		let partid=$partid+1
		MOUNTPOINTS[$partid]="/opt" 
		MOUNTDISKS[$partid]="a"
		MOUNTSIZES[$partid]="$OPTSIZE"
		let PARTITION_START[$partid]=$partstart
		let PARTITION_END[$partid]=$partstart+MOUNTSIZES[$partid]
		let partstart=PARTITION_END[$partid]+1
	fi

	let partid=$partid+1
	MOUNTPOINTS[$partid]="swap" 
	MOUNTDISKS[$partid]="a"
	if [ -z "$SWAPSIZE" ]; then
		MOUNTSIZES[$partid]="1000"
	else
		MOUNTSIZES[$partid]="$SWAPSIZE"
	fi
	let PARTITION_START[$partid]=$partstart
	let PARTITION_END[$partid]=$partstart+MOUNTSIZES[$partid]
	let DISKSIZES[0]=PARTITION_END[$partid]+1
else
	let index=0
	let diskindex=0
	let partnum=0
	let partstart=0

	echo "Disks and partitions:"

	exec 10<$PARTFILE
	while read line<&10
	do
		if [ "$line" = "---" ]; then
			let DISKSIZES[$diskindex]=$partstart
			let diskindex=$diskindex+1
			let partstart=0
			let partnum=0
			if [ $diskindex -gt 3 ]; then
				echo "Sorry, no more than 4 IDE disks..."
				exit 1
			fi
		else
			MOUNTDISKS[$index]="${letters[$diskindex]}"
			MOUNTPOINTS[$index]=${line%\ *}
			MOUNTSIZES[$index]=`echo "${line#*\ }" | sed 's/^[ \t]*//'`
			let PARTITION_START[$index]=$partstart
			let PARTITION_END[$index]=$partstart+MOUNTSIZES[$index]
			if [ $partnum -eq 0 ]; then
				if [ $NUMRAW -gt $diskindex ]; then
					DISKIMGS[$diskindex]=${RAW[$diskindex]}
				else
					DISKIMGS[$diskindex]=`echo "${MOUNTPOINTS[$index]}" | sed 's%\/%%g' | sed 's/[ \t]*$//'`".raw"
				fi
				info " Disk: $diskindex ${DISKIMGS[$diskindex]}"
			fi

			info "  Partition: $partnum ${MOUNTPOINTS[$index]} start: $partstart end: ${PARTITION_END[$index]} size: ${MOUNTSIZES[$index]}"
			let partstart=PARTITION_END[$index]+1
			let index=$index+1
			let partnum=$partnum+1
			
		fi
	done 
	let DISKSIZES[$diskindex]=$partstart
	let NUMDISK=$diskindex
	if [ $diskindex -gt $NUMRAW && $NUMRAW -gt 0 ]; then
		echo "Sorry, --raw should match --part number of disks"
		exit 1
	fi
fi
set -e

info "VMTMPDIR: $VMTMPDIR"
WORKINGDIR=$(mktemp -d -p $VMTMPDIR vm-builder-XXXXXXXXXX) || exit 1

if [ -z "$DESTINATION" ]
then
	if [ -n "$VMHOSTNAME" ] && [ ! "$VMHOSTNAME" = "ubuntu-vm-$SUITE-$ARCH" ] ; then
        	DESTINATION="$PWD/ubuntu-vm-$SUITE-$ARCH-$VMHOSTNAME"
	else
		DESTINATION="$PWD/ubuntu-vm-$SUITE-$ARCH"
	fi
fi

set +e
if [ -n "${SUDO_USER}" ]; then
	sudo -u "${SUDO_USER}" mkdir "${DESTINATION}" 
else
	mkdir "${DESTINATION}" 
fi

if [ $? -ne 0 ]; then
	if [ -z $OVERWRITE ]; then
		echo "Error creating directory ${DESTINATION}. Unable to proceed."
		rmdir  "${WORKINGDIR}"
		exit 1
	else
		info "Overwriting content of ${DESTINATION}"
		rm $DESTINATION/*
	fi
fi
set -e

if [ -z "$IP" ]; then
	IP="DHCP"
else
	if [ -z "$MASK" ]; then
		MASK="255.255.255.0"
		echo "setting mask to \"$MASK\""
	fi
	if [ -z "$NET" ]; then
		NET=`echo $IP | sed 's/\./.0./3' | sed 's/\.[[:digit:]]\{1,3\}$//'` 
		echo "setting network to \"$NET\""
	fi
	if [ -z "$BCAST" ]; then
		BCAST=`echo $IP | sed 's/\./.255./3' | sed 's/\.[[:digit:]]\{1,3\}$//'` 
		echo "setting broadcast to \"$BCAST\""
	fi
	if [ -z "$GW" ]; then
                GW=`echo $IP | sed 's/\./.1./3' | sed 's/\.[[:digit:]]\{1,3\}$//'`
		echo "setting gateway to \"$GW\""
        fi
	if [ -z "$DNS" ]; then
                DNS=`echo $IP | sed 's/\./.1./3' | sed 's/\.[[:digit:]]\{1,3\}$//'`
		echo "setting name server to \"$DNS\""
        fi


fi 

do_initial_user () {
	#
	# Set up a user with sudo etc.
	#

	chroot root adduser --disabled-password --gecos "${NAME}" ${VMUSER} > /dev/null
	chroot root chpasswd <<EOF
${VMUSER}:${PASS}
EOF

	chroot root addgroup --system admin >/dev/null 2>&1
	chroot root adduser ${VMUSER} admin >/dev/null 2>&1

	cat >> root/etc/sudoers << EOF

# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL
EOF

	for group in adm audio cdrom dialout floppy video plugdev dip netdev powerdev lpadmin scanner; do
		chroot root adduser ${VMUSER} $group >/dev/null 2>&1
	done

	# Lock root account
	chroot root chpasswd <<EOF
root:!
EOF
}

do_network_setup () {
	echo $VMHOSTNAME > root/etc/hostname

	cat > root/etc/hosts <<EOF
127.0.0.1 localhost
127.0.1.1 $VMHOSTNAME.$DOMAIN $VMHOSTNAME

# The following lines are desirable for IPv6 capable hosts
::1 ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
ff02::3 ip6-allhosts
EOF

	cat > root/etc/network/interfaces <<EOF
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
EOF
	if [ "$IP" = "DHCP" ]; then
		cat >> root/etc/network/interfaces <<EOF
iface eth0 inet dhcp
EOF
	else
		cat >> root/etc/network/interfaces <<EOF
iface eth0 inet static
        address $IP
        netmask $MASK 
        network $NET
        broadcast $BCAST
        gateway $GW
        # dns-* options are implemented by the resolvconf package, if installed
        dns-nameservers $DNS
        dns-search $DOMAIN
EOF
	fi

	#temporary fix for /var/run/network not being created
	if [ ! -e root/var/run/network ]; then 
		echo "Creating /var/run/network"
		mkdir root/var/run/network
	fi
}

do_kernel_img_conf () {
	mkdir -p root/etc
	cat > root/etc/kernel-img.conf << EOF
do_symlinks = yes
relative_links = yes
do_bootfloppy = no
do_initrd = yes
link_in_boot = no
do_bootloader = no
EOF
}


do_bootloader () {
	#
	# The suite will have defined updategrub
	#
	sed -e "s,%UPDATEGRUB%,$updategrub,g" << EOF | cat >> target/etc/kernel-img.conf
postinst_hook = %UPDATEGRUB%
postrm_hook = %UPDATEGRUB%
EOF
	chroot target apt-get --force-yes -y install grub

	mkdir target/boot/grub

	if [ $ARCH = "amd64" ]
	then
		grubarch="x86_64-pc"
	else
		grubarch="i386-pc"
	fi
	cp target/$grubroot/$grubarch/* target/boot/grub/

	#
	# Create device.map
	#
	echo "(hd0) ${DISKIMGS[0]}" >> device.map
	grub --device-map=device.map --batch<<EOT
root (hd0,0)
setup (hd0)
EOT

	cat > target/boot/grub/device.map << EOF
(fd0)	/dev/fd0
EOF
	suite_generate_device_map

	# Hacky-di-hack.. First generate the template, then remove the errant kopt_2_6 (which hardcodes the root device to /dev/hda1) and then rerun update-grub.
	chroot target $updategrub -y
	suite_mangle_grub_menu_lst
	chroot target $updategrub
	chroot target grub-set-default 0
}

do_disk_images() {
	info "do_disk_images"
	#
	# Create disk images, partitions and format
	#

	for ((i=0; i<${#DISKIMGS[@]}; i++)); do
		if [ $NUMRAW -eq 0 ]; then
			# create disk image
			let size=${DISKSIZES[$i]}*1024
			qemu-img create -f raw ${DISKIMGS[$i]} $size > /dev/null
		fi

		# label the disk
		parted --script ${DISKIMGS[$i]} mklabel msdos
	done
	
	let diskindex=-1
	curdisk=""

	# create the partitions
	for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
		if [ "$curdisk" != "${MOUNTDISKS[$i]}" ]; then
			let diskindex++
			img="${DISKIMGS[$diskindex]}"
			curdisk=${MOUNTDISKS[$i]}
			info "Disk: $curdisk $img"
		fi

		# Create partition and format
		info "  creating partition ${MOUNTPOINTS[$i]} on $img"
		if [ "${MOUNTPOINTS[$i]}" = "swap" ]; then
			parted --script -- $img mkpartfs primary linux-swap ${PARTITION_START[$i]} ${PARTITION_END[$i]}
		else
			parted --script -- $img mkpartfs primary ext2 ${PARTITION_START[$i]} ${PARTITION_END[$i]}
		fi
	done
	
	#mount the disk loops
	for ((i=0;i<${#DISKIMGS[@]};i++)); do
		LOOPDEV[$i]=$(losetup -s -f ${DISKIMGS[$i]})
		kpartx -a ${LOOPDEV[$i]} > /dev/null
	done
	
	#format the partitions
	let diskindex=-1
        curdisk=""
        for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
                if [ "$curdisk" != "${MOUNTDISKS[$i]}" ]; then
                        let diskindex++ || true
                        img="${DISKIMGS[$diskindex]}"
                        curdisk=${MOUNTDISKS[$i]}
			let partindex=1
			mapper=$(echo ${LOOPDEV[$diskindex]} | sed s-/dev/-/dev/mapper/-)
                fi

		if  [ "${MOUNTPOINTS[$i]}" = "swap" ]; then
			info formating ${mapper}p${partindex} as swap for ${MOUNTPOINTS[$i]}
			mkswap ${mapper}p${partindex}	
		else 
			info formating ${mapper}p${partindex} as ext3 for ${MOUNTPOINTS[$i]}
			mkfs.ext3 -q ${mapper}p${partindex}
		fi
		/lib/udev/vol_id --uuid  ${mapper}p${partindex} >  ${MOUNTPOINTS[$i]}.uuid
		let partindex++
	done
}

do_source() {
	info "do_source $1 $2, iso: $ISO"
	if [ -n "$ISO" ]; then
		# source is an ISO file
		if [ -e "$ISO" ]; then
			# the file exists
			if [ -n "$2" ]; then
				# this is not the first time: need to unmount the previous first
				umount $2/isomnt || true
				rmdir $2/isomnt
				MIRROR="file:///isomnt"
			else
				MIRROR="file://$1/isomnt"
			fi
			if [ ! "$1" = "-" ]; then
				# we have something to mount
				mkdir $1/isomnt
				mount -o loop -t iso9660 $ISO $1/isomnt
			fi
			info "using $MIRROR"
		else
			echo "$ISO not found, using $MIRROR"
		fi
	fi
	if [ -n "$2" ]; then
		# this is not the first time, update the source.list on the target
		if [ "$1" = "-" ]; then
			# this the last time we are called, push the --mirror info
			do_sourceslist $ORIGMIRROR $SECURITY_MIRROR $2
		else
			do_sourceslist $MIRROR $SECURITY_MIRROR $1
		fi
		# Update the cache
		sudo chroot $1 apt-get update &> /dev/null || true
	fi
}

do_debootstrap() {
	mkdir root
	if [ -n "$INSTALL_IN_PLACE" ]
	then
		ln -s target root
	else
		mkdir root &> /dev/null || true 
	fi
	info "debootstrap"
	debootstrap --components="$COMPS" --arch $ARCH --keyring /usr/share/keyrings/ubuntu-archive-keyring.gpg $SUITE root "$MIRROR"
}

do_kernel_n_friends () {
	info "kernel_n_friends"
	PKGS="linux-$KERNEL_FLAVOUR"
	vm_extra_packages
	suite_extra_packages
	chroot root apt-get -o APT::Install-Recommends=False --force-yes -y install $PKGS
}

do_add_remove_packages () {
	info "add_remove_packages"
	cmd="apt-get --purge install "
	chroot root apt-get -y --force-yes --purge install $PKGCMD || true
}

do_add_ssh_key () {
	info "add_ssh_key"
	sshinstalled=""
	test -z "$SSHKEY" && test -z "$SSHUKEY" && return
	if [ -f "$SSHKEY" ]
	then
		mkdir root/root/.ssh
	        cp "$SSHKEY" root/root/.ssh/authorized_keys
	        chroot root chown -R root:root /root/.ssh
		sshinstalled="true"
	else
		test -n "$SSHKEY" && echo "No ssh root key found: $SSHKEY"
	fi
	if [ -f "$SSHUKEY" ]
        then
                mkdir root/home/$VMUSER/.ssh
                cp "$SSHUKEY" root/home/$VMUSER/.ssh/authorized_keys
                chroot root chown -R $VMUSER:$VMUSER /home/$VMUSER/.ssh
		sshinstalled="true"
        else
                test -n "$SSHUKEY" && echo "No ssh user key found: $SSHUKEY"
        fi
	if [ -n "$sshinstalled" ]; then
		chroot root apt-get install --force-yes -y openssh-server || true
	fi
}



do_sourceslist () {
	info "sourceslists $1 $2 $3"
	cat > $3/etc/apt/sources.list << EOF
deb $1 ${SUITE} main restricted
#deb-src $1 ${SUITE} main restricted

## Major bug fix updates produced after the final release of the
## distribution.
deb $1 ${SUITE}-updates main restricted
#deb-src $1 ${SUITE}-updates main restricted 

deb $2 ${SUITE}-security main restricted
#deb-src $2 ${SUITE}-security main restricted
EOF
	## UNIVERSE ##

	if echo $COMPS | grep universe &> /dev/null 
	then
		cat >> $3/etc/apt/sources.list << EOF
## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
## team, and may not be under a free licence. Please satisfy yourself as to
## your rights to use the software. Also, please note that software in
## universe WILL NOT receive any review or updates from the Ubuntu security
## team.
deb $1 ${SUITE} universe
#deb-src $1 ${SUITE} universe
deb $1 ${SUITE}-updates universe
#deb-src $1 ${SUITE}-updates universe
deb $2 ${SUITE}-security universe
#deb-src $2 ${SUITE}-security universe
EOF
	else
		cat >> $3/etc/apt/sources.list << EOF
## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu
## team, and may not be under a free licence. Please satisfy yourself as to
## your rights to use the software. Also, please note that software in
## universe WILL NOT receive any review or updates from the Ubuntu security
## team.
#deb $1 ${SUITE} universe
#deb-src $1 ${SUITE} universe
#deb $1 ${SUITE}-updates universe
#deb-src $1 ${SUITE}-updates universe
#deb $2 ${SUITE}-security universe
#deb-src $2 ${SUITE}-security universe
EOF
	fi

	## MULTIVERSE ##
		
	if echo $COMPS | grep multiverse &> /dev/null 
	then
		cat >> $3/etc/apt/sources.list << EOF
## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu 
## team, and may not be under a free licence. Please satisfy yourself as to 
## your rights to use the software. Also, please note that software in 
## multiverse WILL NOT receive any review or updates from the Ubuntu
## security team.
deb $1 ${SUITE} multiverse
#deb-src $1 ${SUITE} multiverse
deb $1 ${SUITE}-updates multiverse
#deb-src $1 ${SUITE}-updates multiverse
deb $2 ${SUITE}-security multiverse
#deb-src $2 ${SUITE}-security multiverse
EOF
	else
		cat >> $3/etc/apt/sources.list << EOF
## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu 
## team, and may not be under a free licence. Please satisfy yourself as to 
## your rights to use the software. Also, please note that software in 
## multiverse WILL NOT receive any review or updates from the Ubuntu
## security team.
#deb $1 ${SUITE} multiverse
#deb-src $1 ${SUITE} multiverse
#deb $1 ${SUITE}-updates multiverse
#deb-src $1 ${SUITE}-updates multiverse
#deb $2 ${SUITE}-security multiverse
#deb-src $2 ${SUITE}-security multiverse
EOF
	fi
	cat >> $3/etc/apt/sources.list << EOF
## Uncomment the following two lines to add software from the 'backports'
## repository.
## N.B. software from this repository may not have been tested as
## extensively as that contained in the main release, although it includes
## newer versions of some applications which may provide useful features.
## Also, please note that software in backports WILL NOT receive any review
## or updates from the Ubuntu security team.
# deb $1 ${SUITE}-backports main restricted universe multiverse
# deb-src $1 ${SUITE}-backports main restricted universe multiverse

## Uncomment the following two lines to add software from Canonical's
## 'partner' repository. This software is not part of Ubuntu, but is
## offered by Canonical and the respective vendors as a service to Ubuntu
## users.
# deb http://archive.canonical.com/ubuntu hardy partner
# deb-src http://archive.canonical.com/ubuntu hardy partner
EOF
}

do_copy_settings () {
	info "do_copy_settings"
        #copy the host settings to the new guest (locale, console-setup, tz)
        cp /etc/default/locale root/etc/default/
        cp -a /etc/console-setup root/etc/
        cp /etc/default/console-setup root/etc/default/
        cp /etc/timezone root/etc/
        chroot root dpkg-reconfigure -pcritical tzdata
	LANG=$HOSTLANG
	chroot root locale-gen en_US
	chroot root locale-gen $LANG
	chroot root dpkg-reconfigure -pcritical locales
	chroot root dpkg-reconfigure -pcritical console-setup
	info "do_copy_settings done"
}


do_exec_script () {
	info "exec_script"
	if [ -z "$EXEC" ]
	then
		return
	fi

	#
	# Execute the script.
	#
	info "Executing $EXEC"
	sh -c "$EXEC" || {
		echo "Error executing user defined script" 
		do_cleanup
		exit 1
	}
}

do_firstboot () {
	info "firstboot"
	if [ -z "$FIRSTBOOT" ]; then
		return	
	elif [ ! -f "$FIRSTBOOT" ]; then
		echo "Script '$FIRSTBOOT' not found."
		return
	fi
	#
	# Install the script to be executed
	#
	cp $FIRSTBOOT root/root/firstboot.sh
	chmod a+x root/root/firstboot.sh
	mv root/etc/rc.local root/etc/rc.local.orig
	cat > root/etc/rc.local <<EOT
#!/bin/sh -e
#execute firstboot.sh only once
if [ ! -e /root/firstboot_done ]; then
	if [ -e /root/firstboot.sh ]; then
		/root/firstboot.sh
	fi
	touch /root/firstboot_done
fi
exit 0
EOT
	chmod a+x root/etc/rc.local
}

do_firstlogin () {
        info "firstlogin"
	dofirst="YES"
        if [ -z "$FIRSTLOGIN" ]; then
		dofirst=""
        elif [ ! -f "$FIRSTLOGIN" ]; then
                echo "Script '$FIRSTLOGIN' not found."
		dofirst=""
        fi
        #
        # Install the script to be executed
        #
	if [ -n "$dofirst" ]; then 
		cp $FIRSTLOGIN root/root/firstlogin.sh
		chmot a+x root/root/firstlogin.sh
	fi
	cp root/etc/bash.bashrc root/etc/bash.bashrc.orig
	cat >> root/etc/bash.bashrc <<EOT
if [ ! -e /root/firstlogin_done ]; then
	if [ -e /root/firstlogin.sh ]; then
		/root/firstlogin.sh
	fi
	# This part should not be necessary any more
	#echo "Setting up your keyboard, will need sudo password."
	#sudo dpkg-reconfigure -p critical console-setup &> /dev/null
	sudo touch /root/firstlogin_done
fi
EOT
}

mount_parts () {
	info "mount_parts"
	base="$1"
	if [ "$base" = "" ]; then
		echo base is empty....  exiting
		exit 0
	fi
	let diskindex=-1
        curdisk=""
        for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
                if [ "$curdisk" != "${MOUNTDISKS[$i]}" ]; then
                        let diskindex++
                        img="${DISKIMGS[$diskindex]}"
                        curdisk=${MOUNTDISKS[$i]}
                        let partindex=1
			mapper=$(echo ${LOOPDEV[$diskindex]} | sed s-/dev/-/dev/mapper/-)
                fi

                if  [ "${MOUNTPOINTS[$i]}" = "root" ]; then
			mount ${mapper}p${partindex} $base
		elif  [ "${MOUNTPOINTS[$i]}" != "swap" ]; then
			mkdir $base${MOUNTPOINTS[$i]}
			mount ${mapper}p${partindex} $base${MOUNTPOINTS[$i]}
                fi
		let partindex++
        done
}

umount_parts () {
	info "umount_parts"
	base="$1"
	for ((i=$(( ${#MOUNTPOINTS[@]} -1));i>-1;i--)); do
		if  [ "${MOUNTPOINTS[$i]}" = "root" ]; then
			echo umount  $base
			umount  $base
		elif  [ "${MOUNTPOINTS[$i]}" != "swap" ]; then
			echo umount  $base${MOUNTPOINTS[$i]}
			umount  $base${MOUNTPOINTS[$i]}
		fi
	done
}

# Taken from debootstrap
do_avoid_starting_daemons() {
	info "avoid_starting_daemons"
	cat > root/usr/sbin/policy-rc.d <<EOT
#!/bin/sh

while true; do
case "\$1" in
  -*) shift ;;
  makedev) exit 0;;
  x11-common) exit 0;;
  *)  exit 101;;
esac
done
EOT
	chmod 755 "root/usr/sbin/policy-rc.d"
			
}

# Taken from debootstrap
do_undo_avoid_starting_daemons() {
	info "undo_avoid_starting_daemons"
	rm root/usr/sbin/policy-rc.d
}

#
# linux-restricted-modules unconditionally mounts a tmpfs.
#
do_unmount_restricted_tmpfs() {
	info "unmount_restriced_tmpfs"
	umount root/lib/modules/*/volatile > /dev/null 2>&1 || true
}

do_mount_target() {
	info "mount_target"
	mkdir target 
	mount_parts target
}

do_umount_target() {
	info "unmount_target"
	umount_parts target
	rmdir target
}

do_copy_to_disk_images () {
	chroot root apt-get clean
	if [ -e root/isomnt ]; then
		umount root/isomnt
	fi
	if [ -z "$INSTALL_IN_PLACE" ]
	then
		#
		# Copy the debootstrapped filesystem into the partitions
		#
		info Copy the debootstrapped filesystem 
		cp -a root/* target
	fi
	rm -rf root

}

do_target_vm_conversion () {
	info Convert to format $VM
	FILES=""
	vm_target_conversion
	
	#do image conversion if not asked to do raw images
	if  [ $NUMRAW -eq 0 ]; then
		for ((i=0;i<${#DISKIMGS[@]};i++)); do
			img=$( echo ${DISKIMGS[$i]} | sed s/.raw// )
			qemu-img convert $QEMU_IMG_CONVERT_OPTS ${DISKIMGS[$i]} "$img${QEMU_IMG_CONVERT_EXTENSION}"
		done

		test -n "${SUDO_USER}" && chown "$SUDO_USER" $FILES
		mv $FILES $DESTINATION
		echo "Done.  Images are in ${DESTINATION}."
	else 
		echo "Done, raw images/devices ready."
	fi

}

do_cleanup () {
	info "Cleaning up..."
	if [ -n "$VERBOSE" ]; then
		echo "Press return to go ahead with cleanup"
		read
	fi
	#unmount iso if present
	if [ -e $WORKINGDIR/isomnt ]; then
		umount $WORKINGDIR/isomnt
	elif [ -e $WORKINGDIR/target/isomnt ]; then
		umount $WORKINGDIR/target/isomnt
	elif [ -e $WORKINGDIR/root/isomnt ]; then
		umount $WORKINGDIR/root/isomnt
	fi

	#umount target if present
	if [ -e target ]; then
		do_umount_target
	fi

	#unmount the disk loops
        for ((i=0;i<${#DISKIMGS[@]};i++)); do
                kpartx -d ${LOOPDEV[$i]} > /dev/null
		losetup -d ${LOOPDEV[$i]} 
        done

	#remove .uuid files
	for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
		rm ${MOUNTPOINTS[$i]}.uuid
	done
	
	if  [ $NUMRAW -eq 0 ]; then
		#remove .raw files
		for ((i=0;i<${#DISKIMGS[@]};i++)); do
                	rm ${DISKIMGS[$i]} 
        	done
	fi

	#restore curdir
	popd > /dev/null

	#unmount and remove working directory
	if [ -n "$TMPFS" ]; then
		umount "$WORKINGDIR"
	fi
	rm -rf "$WORKINGDIR"
}

function errorHandler () {
	echo "Error"
	do_cleanup
	exit $?
}

function interruptHandler () {
	echo "User interupt"
	do_cleanup
	exit 2
}

if [ -n "$TMPFS" ]; then
	if [ "$TMPFS" = "-" ]; then
		mount -t tmpfs ubuntu-vm-builder -o suid,dev,size=1G "$WORKINGDIR"
	else
		mount -t tmpfs ubuntu-vm-builder -o $TMPFS "$WORKINGDIR"
	fi
fi
info "Working in $WORKINGDIR"
pushd "$WORKINGDIR" > /dev/null

do_disk_images
set +e; trap errorHandler ERR 
trap interruptHandler SIGINT SIGTERM
do_source $WORKINGDIR ""
do_mount_target
do_debootstrap
suite_do_fstab
do_avoid_starting_daemons
do_copy_settings
do_initial_user
do_network_setup
do_source "root" $WORKINGDIR
do_kernel_img_conf 
do_kernel_n_friends
do_add_remove_packages
do_add_ssh_key
do_exec_script
do_firstboot
do_firstlogin
do_undo_avoid_starting_daemons
do_unmount_restricted_tmpfs
do_copy_to_disk_images 
do_source "target" "root"
do_bootloader
do_source "-" "target"
do_umount_target
do_target_vm_conversion
trap - ERR; set -e
do_cleanup
