#!/bin/bash
#
#    Ubuntu Jeos image builder
#    Copyright (C) 2007-2008 Canonical Ltd.
#
#    Authors: Soren Hansen <soren@canonical.com>
#             Neal McBurnett <neal@mcburnett.org>
#             Michael Vogt <michael.vogt@ubuntu.com>
#             Mike Frisch
#             Nick Barcet <nick.barcet@canonical.com>
#             Onno Benschop <onno@itmaze.com.au>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Todo:
#  create launchjeos command for vmware vm's
#  fix perl locale warnings
#  review security of running as root, messing with $DESTINATION

# Keep perl inside the chroot quiet
LANG=C

usage () {
	cat <<EOT
usage: ubuntu-vm-builder    [--addpkg PKG]
                            [(-a|--arch) i386] 
                            [(-d|--dest) <destination (directory)>]
                            [--domain DOMAIN]
                            [-h|--help]
                            [--hostname NAME]
                            [--mem num]
                            [--mirror URL]
                            [--removepkg PKG]
                            [(-s|--suite) hardy]
                            [(-t|--tmp) temp_dir]
                            [--vm (vmw6|vmserver|vbox|qemu|kvm)]
                            [--user username]
                            [--name fullname]
                            [--pass password]
                            [--part partitionfile]
                            [--rootsize size]
                            [--no-opt]
                            [--optsize size]
                            [--swapsize size]
                            [--kernel-flavour <flavour>]
                            [--components <comma separated list of components>]
                            [--ssh-key <public key file>]
                            [--exec <script to execute>]
                            [--libvirt <hypervisor uri>]
                            [--ip address [
                            [--mask value]
                            [--net value]
                            [--bcast value]
                            [--gw address]
                            [--dns address] ]

--addpkg PKG       Install PKG into the guest (can be specfied multiple times)
-a, --arch ARCH    Specify the target architecture. Valid options: i386*, amd64
-d, --dest         Specify the destination directory.
                   Default: ubuntu-vm-$SUITE-$ARCH
--domain DOMAIN    Set DOMAIN as the domain name of the guest. Default:
                   The domain of the machine running this script.
-h, --help         This help text.
-v, --verbose      Show a lot of information as the vm is generated.
--hostname NAME    Set NAME as the hostname of the guest. Default: ubuntu
                   Also uses this name as the VM name
--mem NN           Assign NN megabytes of memory to the guest vm.
                   Default: 128
--mirror URL       Use Ubuntu mirror at URL instead of the default, which
                   is: http://archive.ubuntu.com/ubuntu
--removepkg PKG    Remove PKG from the guest (can be specfied multiple times)
-s, --suite SUITE  Use the specified Ubuntu suite. Valid options: hardy, gutsy,
                   feisty, edgy, dapper
-t, --tmp  TMPDIR  Use TMPDIR as temporary working area for the image
                   generation. Defaults to \$TMPDIR if set, or /tmp if not.
--vm VM            Generate image for specified virtualisation software.
                   Valid choices are: vmw6 vmserver vbox qemu kvm*
--user username    Set the name of the user to be added. Default: ubuntu.
--name fullname    Set the full name of the user to be added. Default: Ubuntu.
--pass password    Set the password for the user. Default: ubuntu.
--no-opt           Do not build the /opt image
--part partfile    Allows to specify a partition table in partfile
                   each line of partfile should specify (root first):
                      mountpoint size
                   where size is in megabytes. You can have up to 4 virtual disks,
                   a new disk starts on a line with ---
                   ie :
                      root 1000
                      /opt 1000
                      swap 256
                      ---
                      /var 2000
                      /log 1500
The following three options are not used if --part is specified:
--rootsize size    The size in MB of the root filesystem (default 1000)
--optsize size     The size in MB of the /opt filesystem (default 4000)
--swapsize size    The size in MB of the swap partition (default 1000)
--kernel-flavour   The kernel image flavour to install (default: virtual for
                   >=gutsy on i386, server otherwise)
--components       A comma seperaed list of distro components to include 
                   (e.g. main,universe). This defaults to "main"
--ssh-key          Add the given ssh public key file (absolute path)
                   to root's authorized keys and install openssh-server
                   (WARNING: this has strong security implications)
--exec             Run the given script file. You can use 
                   'chroot root <cmd>' to execute code in the guest.
--libvirt <uri>    Add resulting VM to the libvirt hypervisor at uri.
--ip address       Ip address in dotted form
                   (defaults to dhcp if not specified)

Options below are discarded if --ip is not specified
--mask value       IP mask in dotted form (default: 255.255.255.0)
--net value        IP net address (default: X.X.X.0)
--bcast value      IP broadcast (default: X.X.X.255)
--gw address       Gateway address (default: X.X.X.1)
--dns address      Name server address (default: X.X.X.1)

('*' denotes default option)

ubuntu-vm-builder is Copyright (C) 2007-2008 Canonical Ltd. and
originally written by Soren Hansen <soren@canonical.com>.
EOT
}

info () {
	test -n "$VERBOSE" && echo "$@"
}

#
# The defaults
#
ARCH="i386"
if [ -z "$TMPDIR" ]
then
	TMPDIR="/tmp"
fi
VM=kvm
USER=ubuntu
NAME=Ubuntu
PASS=ubuntu
SUITE=hardy
MIRROR="http://archive.ubuntu.com/ubuntu"
MEM=128
HOSTNAME="ubuntu"
DOMAIN="`hostname -d`"
ROOTSIZE="1000"
OPTSIZE="4000"
SWAPSIZE="1000"
COMPS="main"
SSHKEY=""
OPTFS="yes"
declare -a MOUNTPOINTS 
declare -a MOUNTSIZES
declare -a MOUNTDISKS
declare -a DISKIMGS
declare -a DISKSIZES
declare -a PARTITION_START
declare -a PARTITION_END

TEMP=`getopt -o a:d:hs:t: --long addpkg:,arch:,dest:,domain:,help,hostname:,mem:,mirror:,removepkg:,suite:,tmp:,vm:,user:,name:,pass:,part:,rootsize:,swapsize:,optsize:,ip:,mask:,net:,bcast:,gw:,dns:,kernel-flavour:,components:,ssh-key:,no-opt,exec:,libvirt:,  -- "$@"`
eval set -- "$TEMP"

while true
do
	case "$1" in 
		--addpkg)
			info "Will add $2 to the guest"
			PKGCMD="$PKGCMD $2"
			shift 2
		;;
		-a|--arch)
			if [ "$2" = i386 ] || [ "$2" = amd64 ]
			then
				info "Setting architecture to \"$2\""
				ARCH="$2"
			else
				echo "Invalid architecture: \"$2\". Valid choices are: i386 amd64"
				exit 1
			fi
			shift 2
		;;
		-d|--dest)
			if [ -d "`dirname $2`" ]
			then
				if [ -w "`dirname $2`" ]
				then
					info "Setting destination to \"$2\""
					if [ ! "${2#/}" = "${2}" ]
					then
						# Absolute path given
						DESTINATION="$2"
					else
						# Relative path given
						DESTINATION="${PWD}/$2"
					fi
				else
					echo "\"`dirname $2`\" is not writable"
					exit 1
				fi
			else
				echo "\"`dirname $2`\" is not a directory"
				exit 1
			fi
			shift 2
		;;
		--domain)
			info "Setting guest domain to $2"
			DOMAIN="$2"
			shift 2
		;;
		--hostname)
			info "Setting guest hostname to $2"
			HOSTNAME="$2"
			shift 2
		;;
		--mem)
			info "Setting guest memory to $2 MB"
			MEM="$2"
			shift 2
		;;
		--mirror)
			info "Setting Ubuntu mirror to \"$2\""
			MIRROR="$2"
			shift 2
		;;
		--removepkg)
			info "Will remove $2 from the guest"
			PKGCMD="$PKGCMD ${2}-"
			shift 2
		;;
		-s|--suite)
			if [ "$2" = gutsy ] || [ "$2" = feisty ] || [ "$2" = "edgy" ] || [ "$2" = dapper ] || [ "$2" = hardy ]
			then
				info "Setting Ubuntu version to \"$2\""
				SUITE="$2"
			else
				echo "Invalid Ubuntu version: \"$2\". Valid choices are: hardy gutsy feisty edgy dapper"
				exit 1
			fi
			shift 2
		;;
		-t|--tmp)
			if [ ! -d "$2" ]
			then
				echo "\"$2\" is not a directory"
				exit 1
			fi
			if [ ! -w "$2" ]
			then
				echo "\"$2\" is not writable"
				exit 1
			fi
			info "Setting temporary working dir to \"$2\""
			TMPDIR="$2"
			shift 2
		;;
		--vm)
			if [ "$2" = vmw6 ] || [ "$2" = vmserver ] || [ "$2" = vbox ] || [ "$2" = qemu ] || [ "$2" = kvm ]
			then
				info "Setting target vm to \"$2\""
				VM="$2"
			else
				echo "Invalid vm software: \"$2\". Valid choices are: vmw6 vmserver vbox qemu kvm"
				exit 1
			fi
			shift 2
		;;
		--user)
			info "Setting username to: \"$2\""
			USER="$2"
			shift 2
		;;
		--name)
			info "Setting fullname to: \"$2\""
			NAME="$2"
			shift 2
		;;
		--pass)
			info "Setting password to: \"$2\""
			PASS="$2"
   			shift 2
		;;
		--part)
			info "Setting partitions from \"$2\""
			PARTFILE="$2"
			shift 2
		;;
		--rootsize)
			info "Setting rootsize to \"$2\""
			ROOTSIZE="$2"
			shift 2
		;;
		--swapsize)
			info "Setting swapsize to \"$2\""
			SWAPSIZE="$2"
			shift 2
		;;
		--optsize)
			info "Setting optsize to \"$2\""
			OPTSIZE="$2"
			shift 2
		;;
		--kernel-flavour)
			info "Setting kernel flavour to \"$2\""
			KERNEL_FLAVOUR="$2"
			shift 2
		;;
		--components)
	        info "Setting compoents to \"$2\""
			COMPS="$2"
			shift 2
		;;
		--ssh-key)
			info "Setting ssh-key to \"$2\""
			SSHKEY="$2"
			shift 2
		;;
		--exec)
			info "Setting exec script to \"$2\""
			EXEC="$2"
			shift 2
		;;
		--ip)
			info "setting ipaddress to \"$2\""
			IP="$2"
			shift 2
		;;
		--mask)
			info "setting mask to \"$2\""
			MASK="$2"
			shift 2
		;;
		--net)
			info "setting network to \"$2\""
			NETWORK="$2"
			shift 2
		;;
		--bcast)
			info "setting broadcast to \"$2\""
			BCAST="$2"
			shift 2
		;;
		--gw)
			info "setting gateway to \"$2\""
			GW=$2
			shift 2
		;;
		--dns)
			info "setting name server to \"$2\""
			DNS=$2
			shift 2
		;;
		--no-opt)
			info "Not building /opt"
			OPTFS="no"
			shift 1
		;;
		-v|--verbose)
			VERBOSE="YEAH"
			shift 1
		;;
		--libvirt)
			info "Using libvirt uri '$2'"
			LIBVIRT="$2"
			shift 2
		;;
		--)
			shift
			break
		;;
		-h|--help)
			usage
			exit 0
			;;
		*)
			echo "Unknown option: $1"
			usage
			exit 1
			;;
	esac
done

if [ $# -gt 0 ];
then
	usage
	exit 1
fi

if [ -n "$LIBVIRT" ] && ! [ "$VM" = "kvm" -o "$VM" = "qemu" ];
then
	echo "--libvirt is only available for --vm kvm and --vm qemu (not $VM)"
	exit 1
fi

if [ ! "`id -u`" = 0 ]
then
	echo "$0 must be run as root (e.g. by means of sudo)"
	exit 1
fi

# DISKIMGS holds the base names of the disk image files.
# MOUNTPOINTS[i] holds the mountpoint of partition i.
# MOUNTDISKS[i] holds
# MOUNTSIZES[i] holds the size of partition i.
if [ -z "$PARTFILE" ]; then
	let partstart=0
	let partid=0
	let NUMDISKS=0
	DISKIMGS[0]="root"

	MOUNTPOINTS[$partid]="root" 
	MOUNTDISKS[$partid]="a"
	MOUNTSIZES[$partid]="$ROOTSIZE"
	let PARTITION_START[$partid]=$partstart
	let PARTITION_END[$partid]=$partstart+MOUNTSIZES[$partid]
	let partstart=PARTITION_END[$partid]+1

	if [ "$OPTFS" = "yes" ]
	then
		let partid=$partid+1
		MOUNTPOINTS[$partid]="/opt" 
		MOUNTDISKS[$partid]="a"
		if [ -z "$OPTSIZE" ]; then
			MOUNTSIZES[$partid]="4000"
		else
			MOUNTSIZES[$partid]="$OPTSIZE"
		fi
		let PARTITION_START[$partid]=$partstart
		let PARTITION_END[$partid]=$partstart+MOUNTSIZES[$partid]
		let partstart=PARTITION_END[$partid]+1
	fi

	let partid=$partid+1
	MOUNTPOINTS[$partid]="swap" 
	MOUNTDISKS[$partid]="a"
	if [ -z "$SWAPSIZE" ]; then
		MOUNTSIZES[$partid]="1000"
	else
		MOUNTSIZES[$partid]="$SWAPSIZE"
	fi
	let PARTITION_START[$partid]=$partstart
	let PARTITION_END[$partid]=$partstart+MOUNTSIZES[$partid]
	let DISKSIZES[0]=PARTITION_END[$partid]+1
else
	letters=("a" "b" "c" "d")
	let index=0
	let diskindex=0
	let partnum=0
	let partstart=0

	echo "Disks and partitions:"

	exec 10<$PARTFILE
	while read line<&10
	do
		if [ "$line" = "---" ]; then
			let DISKSIZES[$diskindex]=$partstart
			let diskindex=$diskindex+1
			let partstart=0
			let partnum=0
			if [ $diskindex -gt 3 ]; then
				echo "Sorry, no more than 4 IDE disks..."
				exit 1
			fi
		else
			MOUNTDISKS[$index]="${letters[$diskindex]}"
			MOUNTPOINTS[$index]=${line%\ *}
			MOUNTSIZES[$index]=`echo "${line#*\ }" | sed 's/^[ \t]*//'`
			let PARTITION_START[$index]=$partstart
			let PARTITION_END[$index]=$partstart+MOUNTSIZES[$index]
			if [ $partnum -eq 0 ]; then
				DISKIMGS[$diskindex]=`echo "${MOUNTPOINTS[$index]}" | sed 's%\/%%g' | sed 's/[ \t]*$//'`
				info " Disk: $diskindex ${DISKIMGS[$diskindex]}"
			fi

			info "  Partition: $partnum ${MOUNTPOINTS[$index]} start: $partstart end: ${PARTITION_END[$index]} size: ${MOUNTSIZES[$index]}"
			let partstart=PARTITION_END[$index]+1
			let index=$index+1
			let partnum=$partnum+1
			
		fi
	done 
	let DISKSIZES[$diskindex]=$partstart
	let NUMDISK=$diskindex
fi

WORKINGDIR=`mktemp -d -p $TMPDIR vm-builder-XXXXXXXXXX` || exit 1

if [ -z "$DESTINATION" ]
then
        DESTINATION="$PWD/ubuntu-vm-$SUITE-$ARCH"
fi

if [ -z "$KERNEL_FLAVOUR" ]
then
	if [ "$ARCH" = "i386"] && [ "$SUITE" = "gutsy" -o "$SUITE" = "hardy" ]
	then
		KERNEL_FLAVOUR="virtual"
	else
		KERNEL_FLAVOUR="server"
	fi
fi
info "Using kernel flavour: $KERNEL_FLAVOUR"

if [ -n "${SUDO_USER}" ]; then
	sudo -u "${SUDO_USER}" mkdir "${DESTINATION}"
else
	mkdir "${DESTINATION}"
fi

if [ $? -ne 0 ]; then
	echo "Error creating directory ${DESTINATION}. Unable to proceed."
	rm -rf "${WORKINGDIR}"
	exit 1
fi

if [ -z "$IP" ]; then
	IP="DHCP"
else
	if [ -z "$MASK" ]; then
		MASK="255.255.255.0"
		echo "setting mask to \"$MASK\""
	fi
	if [ -z "$NET" ]; then
		NET=`echo $IP | sed 's/\./.0./3' | sed 's/\.[[:digit:]]\{1,3\}$//'` 
		echo "setting network to \"$NET\""
	fi
	if [ -z "$BCAST" ]; then
		BCAST=`echo $IP | sed 's/\./.255./3' | sed 's/\.[[:digit:]]\{1,3\}$//'` 
		echo "setting broadcast to \"$BCAST\""
	fi
	if [ -z "$GW" ]; then
                GW=`echo $IP | sed 's/\./.1./3' | sed 's/\.[[:digit:]]\{1,3\}$//'`
		echo "setting gateway to \"$GW\""
        fi
	if [ -z "$DNS" ]; then
                DNS=`echo $IP | sed 's/\./.1./3' | sed 's/\.[[:digit:]]\{1,3\}$//'`
		echo "setting name server to \"$DNS\""
        fi


fi 

do_initial_user () {
	#
	# Set up a user with sudo etc.
	#

	chroot root adduser --disabled-password --gecos "${NAME}" ${USER} > /dev/null
	chroot root chpasswd <<EOF
${USER}:${PASS}
EOF

	chroot root addgroup --system admin >/dev/null 2>&1
	chroot root adduser ${USER} admin >/dev/null 2>&1

	cat >> root/etc/sudoers << EOF

# Members of the admin group may gain root privileges
%admin ALL=(ALL) ALL
EOF

	for group in adm audio cdrom dialout floppy video plugdev dip netdev powerdev lpadmin scanner; do
		chroot root adduser ${USER} $group >/dev/null 2>&1
	done

}

do_network_setup () {
	echo $HOSTNAME > root/etc/hostname

	cat > root/etc/hosts <<EOF
127.0.0.1 localhost
127.0.1.1 $HOSTNAME.$DOMAIN $HOSTNAME
EOF

	cat > root/etc/network/interfaces <<EOF
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
EOF
	if [ "$IP" = "DHCP" ]; then
		cat >> root/etc/network/interfaces <<EOF
iface eth0 inet dhcp
EOF
	else
		cat >> root/etc/network/interfaces <<EOF
iface eth0 inet static
        address $IP
        netmask $MASK 
        network $NET
        broadcast $BCAST
        gateway $GW
        # dns-* options are implemented by the resolvconf package, if installed
        dns-nameservers $DNS
        dns-search $DOMAIN
EOF
	fi

	#temporary fix for /var/run/network not being created
	if [ ! -e root/var/run/network ]; then 
		echo "Creating /var/run/network"
		mkdir root/var/run/network
	fi
}

do_bootloader () {
        updategrub="\/usr\/sbin\/update-grub"
	if [ "$SUITE" = dapper -o "$SUITE" = edgy ]
	then
	    updategrub="\/sbin\/update-grub"
	fi
	sed -e "s/%UPDATEGRUB%/$updategrub/g" << EOF | cat > root/etc/kernel-img.conf
do_symlinks = yes
relative_links = yes
do_bootfloppy = no
do_initrd = yes
link_in_boot = no
postinst_hook = %UPDATEGRUB%
postrm_hook = %UPDATEGRUB%
do_bootloader = no
EOF

	chroot root apt-get --force-yes -y install grub


	mkdir root/boot/grub
	#
	# Create device.map
	#
	cat > root/boot/grub/device.map << EOF
(fd0)	/dev/fd0
EOF
	if [ "$SUITE" = dapper ]
        then
		echo "(hd0) /dev/sd${letters[0]}" >> root/boot/grub/device.map
	else
		echo "(hd0) UUID=$(cat ${MOUNTPOINTS[0]}.uuid)" >> root/boot/grub/device.map
	fi

	if [ $ARCH = "amd64" ]
	then
		grubarch="x86_64-pc"
	else
		grubarch="i386-pc"
	fi
	#
	# No animals (and only one human) were harmed during the making of the following boot loader installation.
	#

	# This should replicate pretty closely what grub's stage2 shell does when asked to install
	BOOTSEC_BPB_OFFSET=$((0x3))
	BOOTSEC_BPB_LENGTH=$((0x3B))
	STAGE1_WINDOWS_NT_MAGIC=$((0x1b8))
	STAGE1_PARTEND=$((0x1fe))
	STAGE1_BOOT_DRIVE=$((0x40))
	STAGE1_BOOT_DRIVE_CHECK=$((0x4b))
	STAGE1_STAGE2_SECTOR=$((0x44))
	STAGE1_STAGE2_ADDRESS=$((0x42))
	STAGE1_STAGE2_SEGMENT=$((0x48))
	STAGE2_FORCE_LBA=$((0x11))
	STAGE2_VER_STR_OFFS=$((0x12))

	# *sigh* dapper and edgy are a bit special
	grubroot=root/usr/lib/grub/
	updategrub=/usr/sbin/update-grub
	if [ "$SUITE" = dapper -o "$SUITE" = edgy ]
	then
	    grubroot=root/lib/grub
	    updategrub=/sbin/update-grub
	fi
	cp $grubroot/$grubarch/stage1 stage1_buffer
	dd bs=512 count=1 if=root.raw of=old_sect 2> /dev/null

	dd bs=1 count=$BOOTSEC_BPB_LENGTH conv=notrunc skip=$BOOTSEC_BPB_OFFSET seek=$BOOTSEC_BPB_OFFSET if=old_sect of=stage1_buffer 2> /dev/null
	dd bs=1 count=$(($STAGE1_PARTEND - $STAGE1_WINDOWS_NT_MAGIC)) conv=notrunc skip=$STAGE1_WINDOWS_NT_MAGIC seek=$STAGE1_WINDOWS_NT_MAGIC if=old_sect of=stage1_buffer 2> /dev/null

	# Set boot device to GRUB_UNKNOWN_DEVICE (that's what grub does) and force lba
	/bin/echo -ne '\xff\01' | dd bs=1 count=2 conv=notrunc seek=$STAGE1_BOOT_DRIVE of=stage1_buffer 2> /dev/null

	# Hack to workaround buggy bios'es
	/bin/echo -ne '\x90\x90' | dd bs=1 count=2 conv=notrunc seek=$STAGE1_BOOT_DRIVE_CHECK of=stage1_buffer 2> /dev/null

	dd if=$grubroot/$grubarch/e2fs_stage1_5 of=stage2_first_buffer bs=512 count=1 2> /dev/null
	dd if=$grubroot/$grubarch/e2fs_stage1_5 of=stage2_second_buffer bs=512 count=1 skip=1 2> /dev/null

	# Stage 2 (actually 1.5) is at sector 1 (0-indexed)
	/bin/echo -ne '\1\0\0\0' | dd bs=1 count=4 conv=notrunc seek=$STAGE1_STAGE2_SECTOR of=stage1_buffer 2> /dev/null
	# Set address and segment accordingly
	/bin/echo -ne '\0\x20' | dd bs=1 count=2 conv=notrunc seek=$STAGE1_STAGE2_ADDRESS of=stage1_buffer 2> /dev/null
	/bin/echo -ne '\0\02' | dd bs=1 count=2 conv=notrunc seek=$STAGE1_STAGE2_SEGMENT of=stage1_buffer 2> /dev/null

	/bin/echo -ne '\1' | dd bs=1 count=1 conv=notrunc seek=$STAGE2_FORCE_LBA of=stage2_second_buffer 2> /dev/null

	# These two are unexplained.. 
	/bin/echo -ne '\x10' | dd bs=1 count=1 conv=notrunc seek=508 of=stage2_first_buffer 2> /dev/null
	/bin/echo -ne '\0' | dd bs=1 count=1 conv=notrunc seek=$((0x19)) of=stage2_second_buffer 2> /dev/null

	# I couldn't figure out how to reimplement this properly in posix shell, so I'll hardcode the offset for now

	/bin/echo -ne ' /boot/grub/menu.lst\0' | dd bs=1 count=21 conv=notrunc seek=$((0x2c)) of=stage2_second_buffer 2> /dev/null

	#
	# Stuff this all back into the disk image
	#
	dd bs=512 count=1               if=stage1_buffer                              conv=notrunc of=root.raw 2> /dev/null
	dd bs=512 count=1 seek=1        if=stage2_first_buffer                        conv=notrunc of=root.raw 2> /dev/null
	dd bs=512 count=1 seek=2        if=stage2_second_buffer                       conv=notrunc of=root.raw 2> /dev/null
	dd bs=512         seek=3 skip=2 if=$grubroot/$grubarch/e2fs_stage1_5 conv=notrunc of=root.raw 2> /dev/null

	cp $grubroot/$grubarch/* root/boot/grub/

	# Hacky-di-hack.. First generate the template, then remove the errant kopt_2_6 (which hardcodes the root device to /dev/hda1) and then rerun update-grub.
	chroot root $updategrub -y
	if [ "$SUITE" = dapper ]; then
		sed -ie '/^# kopt_2_6/ d' root/boot/grub/menu.lst
	else
		rep="UUID=$(cat ${MOUNTPOINTS[0]}.uuid)"
		sed -ie "s/\/dev\/hda1/$rep/g" root/boot/grub/menu.lst
	fi
	chroot root $updategrub
	chroot root grub-set-default 0
	rm old_sect stage1_buffer stage2_first_buffer stage2_second_buffer
}

do_disk_images() {
	#
	# Create disk images, partitions and format
	#

	for ((i=0; i<${#DISKIMGS[@]}; i++)); do
		# create disk image
		let size=${DISKSIZES[$i]}*1024
		qemu-img create -f raw ${DISKIMGS[$i]}.raw $size > /dev/null

		# label the disk
		parted --script ${DISKIMGS[$i]}.raw mklabel msdos
	done
	
	let diskindex=-1
	curdisk=""

	# create the partitions
	for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
		if [ "$curdisk" != "${MOUNTDISKS[$i]i}" ]; then
			let diskindex++
			img="${DISKIMGS[$diskindex]}"
			curdisk=${MOUNTDISKS[$i]}
			info "Disk: $curdisk $img"
		fi

		# Create partition and format
		info "  creating partition ${MOUNTPOINTS[$i]} on $img"
		if [ "${MOUNTPOINTS[$i]}" = "swap" ]; then
			parted --script -- $img.raw mkpartfs primary linux-swap ${PARTITION_START[$i]} ${PARTITION_END[$i]}
		else
			parted --script -- $img.raw mkpartfs primary ext2 ${PARTITION_START[$i]} ${PARTITION_END[$i]}
		fi
	done
	
	#mount the disk loops
	for ((i=0;i<${#DISKIMGS[@]};i++)); do
		kpartx -av ${DISKIMGS[$i]}.raw
	done
	
	#format the partitions
	let diskindex=-1
        curdisk=""
        for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
                if [ "$curdisk" != "${MOUNTDISKS[$i]}" ]; then
                        let diskindex++
                        img="${DISKIMGS[$diskindex]}"
                        curdisk=${MOUNTDISKS[$i]}
			let partindex=1
                fi
		if  [ "${MOUNTPOINTS[$i]}" = "swap" ]; then
			info formating /dev/mapper/loop${diskindex}p${partindex} as swap for ${MOUNTPOINTS[$i]}
			mkswap /dev/mapper/loop${diskindex}p${partindex}	
		else 
			info formating /dev/mapper/loop${diskindex}p${partindex} as ext3 for ${MOUNTPOINTS[$i]}
			mkfs.ext3 -q /dev/mapper/loop${diskindex}p${partindex}
		fi
		/lib/udev/vol_id --uuid  /dev/mapper/loop${diskindex}p${partindex} >  ${MOUNTPOINTS[$i]}.uuid
		let partindex++
	done

}

do_debootstrap() {
	mkdir root
	debootstrap --components="$COMPS" --arch $ARCH $SUITE root "$MIRROR"
}

do_fstab_dapper() {
	#
	# Set up fstab
	#
        cat > root/etc/fstab << EOF
# /etc/fstab: static file system information.
#
# <file system>					<mount point>	<type>	<options>	<dump>	<pass>
proc						/proc		proc	defaults	0	0
EOF
	for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
		if [ "${MOUNTPOINTS[$i]}" = "root" ]; then
			echo "/dev/hd${MOUNTDISKS[$i]}1	/	ext3	defaults	0	1">>root/etc/fstab
		elif [ "${MOUNTPOINTS[$i]}" = "swap" ]; then
			echo "/dev/hd${MOUNTDISKS[$i]}1	swap      swap    defaults        0       1">>root/etc/fstab
		else 
			echo "/dev/hd${MOUNTDISKS[$i]}1	${MOUNTPOINTS[$i]}       ext3    defaults        0       1">>root/etc/fstab
		fi
	done
}

do_fstab() {
	#
	# Set up fstab
	#
	cat > root/etc/fstab << EOF
# /etc/fstab: static file system information.
#
# <file system>                                 <mount point>   <type>  <options>       <dump>  <pass>
proc                                            /proc           proc    defaults        0       0
EOF
	for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
                if [ "${MOUNTPOINTS[$i]}" = "root" ]; then
                        echo "UUID=$(cat ${MOUNTPOINTS[$i]}.uuid) /       ext3    defaults        0       1">>root/etc/fstab
                elif [ "${MOUNTPOINTS[$i]}" = "swap" ]; then
                        echo "UUID=$(cat ${MOUNTPOINTS[$i]}.uuid) swap      swap    defaults        0       1">>root/etc/fstab
                else
                        echo "UUID=$(cat ${MOUNTPOINTS[$i]}.uuid) ${MOUNTPOINTS[$i]}       ext3    defaults        0       1">>root/etc/fstab
                fi
        done
}

do_kernel_n_friends () {

	PKGS="linux-$KERNEL_FLAVOUR"
	if [ "$SUITE" != dapper ]
	then
		PKGS="$PKGS usplash usplash-theme-ubuntu"
	fi
	chroot root apt-get --force-yes -y install $PKGS
}

do_add_remove_packages () {
	cmd="apt-get --purge install "
	chroot root apt-get --purge install $PKGCMD
}

do_add_ssh_key () {
        if [ -z "$SSHKEY" ]
	then
	    return
	fi
	if [ ! -f "$SSHKEY" ]
	then
	    echo "NO $SSHKEY found"
	    return
	fi
	# we have a key, add it
	chroot root apt-get install --force-yes -y openssh-server
	mkdir root/root/.ssh
	cp "$SSHKEY" root/root/.ssh/authorized_keys
}

do_exec_script () {
       if [ ! -f "$EXEC" ]
       then
           echo "Script '$EXEC' not found."
           return
       fi
       #
       # Execute the script.
       #
       "$EXEC"
}

mount_parts () {
	base="$1"
	if [ "$base" = "" ]; then
		echo base is empty....  exiting
		exit 0
	fi
	let diskindex=-1
        curdisk=""
        for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
                if [ "$curdisk" != "${MOUNTDISKS[$i]}" ]; then
                        let diskindex++
                        img="${DISKIMGS[$diskindex]}"
                        curdisk=${MOUNTDISKS[$i]}
                        let partindex=1
                fi

                if  [ "${MOUNTPOINTS[$i]}" = "root" ]; then
			mount /dev/mapper/loop${diskindex}p${partindex} $base
		elif  [ "${MOUNTPOINTS[$i]}" != "swap" ]; then
			mkdir $base${MOUNTPOINTS[$i]}
			mount /dev/mapper/loop${diskindex}p${partindex} $base${MOUNTPOINTS[$i]}
                fi
		let partindex++
        done
}

umount_parts () {
	base="$1"
        for ((i=${#MOUNTPOINTS[@]};i>-1;i--)); do
                if  [ "${MOUNTPOINTS[$i]}" = "root" ]; then
                        umount  $base
                elif  [ "${MOUNTPOINTS[$i]}" != "swap" ]; then
                        umount  $base${MOUNTPOINTS[$i]}
                fi
        done
}

do_copy_to_disk_images () {

	chroot root apt-get clean
	#
	# Copy the debootstrapped filesystem into the partitions
	#
	mkdir target 
	mount_parts target
	info Copy the debootstrapped filesystem 
	cp -a root/* target
	umount_parts target
	rmdir target
	rm -rf root
}

do_target_vm_conversion () {
	info Convert to format $VM

	if [ $VM = vmserver ]
	then
		QEMU_IMG_CONVERT_OPTS="-O vmdk"
		VMHWVERSION=4
	elif [ $VM = vmw6 ]
	then
		QEMU_IMG_CONVERT_OPTS="-O vmdk -6"
		VMHWVERSION=6
	fi

	if [ $ARCH = "amd64" ]
	then
		guestos="ubuntu-64"
	else
		guestos="ubuntu"
	fi

	if [ "$VM" = vmserver ] || [ "$VM" = vmw6 ]
	then
		QEMU_IMG_CONVERT_EXTENSION=".vmdk"
		cat > $HOSTNAME.vmx << EOF
config.version = "8"
virtualHW.version = "$VMHWVERSION"
scsi0.present = "FALSE"
scsi0.virtualDev = "lsilogic"
memsize = "$MEM"
Ethernet0.virtualDev = "vlance"
Ethernet0.present = "TRUE"
Ethernet0.connectionType = "bridged"
displayName = "$HOSTNAME $ARCH"
guestOS = "$guestos"
priority.grabbed = "normal"
priority.ungrabbed = "normal"
powerType.powerOff = "hard"
powerType.powerOn = "hard"
powerType.suspend = "hard"
powerType.reset = "hard"
floppy0.present = "FALSE"

EOF

		chmod +x $HOSTNAME.vmx
		FILES="$HOSTNAME.vmx"
		for ((i=0;i<${#DISKIMGS[@]};i++)); do
			FILES="$FILES ${DISKIMGS[$i]}.vmdk"
			let "id=$i%2"
			let "bus=$i/2"
			echo "ide${bus}:${id}.present = \"TRUE\"">>$HOSTNAME.vmx
			echo "ide${bus}:${id}.fileName = \"${DISKIMGS[$i]}.vmdk\"">>$HOSTNAME.vmx
		done

	elif [ $VM = qemu ] || [ $VM = kvm ]
	then
		QEMU_IMG_CONVERT_OPTS="-O qcow2"
		QEMU_IMG_CONVERT_EXTENSION=".qcow2"
		if [ $VM = kvm ]
		then
			CMD=kvm
		else
			CMD=qemu
		fi
	
		if [ -n "$LIBVIRT" ]
		then
			LIBVIRTXML=`mktemp -p $TMPDIR vm-builder-XXXXXXXXXX` || exit 1
			LIBVIRTNAME="$HOSTNAME"
			MAC="52:54:00$(hexdump -e '/1 ":%02x"' -n 3 /dev/urandom)"
			while virsh -c "$LIBVIRT" dumpxml "$LIBVIRTNAME" > /dev/null 2>&1
			do
				LIBVIRTNAME="${LIBVIRTNAME}_"
			done
			cat > ${LIBVIRTXML} <<EOXML
<domain type='$VM'>
  <name>${LIBVIRTNAME}</name>
  <memory>$(( $MEM * 1024))</memory>
  <vcpu>1</vcpu>
  <os>
    <type>hvm</type>
    <boot dev='hd'/>
  </os>
  <clock offset='utc'/>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>destroy</on_crash>
  <devices>
    <emulator>/usr/bin/${VM}</emulator>
    <interface type='network'>
      <mac address='${MAC}'/>
      <source network='default'/>
    </interface>
    <input type='mouse' bus='ps2'/>
    <graphics type='vnc' port='-1' listen='127.0.0.1'/>
EOXML
			let diskindex=-1
			curdisk=""
			for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
				if [ "$curdisk" != "${MOUNTDISKS[$i]}" ]; then
					let diskindex++
					img="${DISKIMGS[$diskindex]}"
					curdisk=${MOUNTDISKS[$i]}
   	             	FILES="$FILES $img.qcow2"
					cat >> ${LIBVIRTXML} << EOXML

    <disk type='file' device='disk'>
      <source file='${DESTINATION}/${img}.qcow2'/>
      <target dev='hd${curdisk}'/>
    </disk>
EOXML
				fi
			done
			cat >> ${LIBVIRTXML} << EOXML	
  </devices>
</domain>
EOXML
			virsh -c "${LIBVIRT}" define "${LIBVIRTXML}"
			rm $LIBVIRTXML
		else
	   		FILES="$HOSTNAME.$CMD" 
			IMGFILES=""
			let diskindex=-1
			curdisk=""
			for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
				if [ "$curdisk" != "${MOUNTDISKS[$i]}" ]; then
					let diskindex++
					img="${DISKIMGS[$diskindex]}"
					curdisk=${MOUNTDISKS[$i]}
					FILES="$FILES $img.qcow2"
					IMGFILES="$IMGFILES -hd$curdisk $img.qcow2" 
				fi
			done
			cat > $HOSTNAME.$CMD <<EOF
#!/bin/sh
$CMD -m $MEM $IMGFILES "\$@"
EOF
			chmod +x $HOSTNAME.$CMD
		fi
	fi

	for ((i=0;i<${#DISKIMGS[@]};i++)); do
		qemu-img convert $QEMU_IMG_CONVERT_OPTS ${DISKIMGS[$i]}.raw "${DISKIMGS[$i]}${QEMU_IMG_CONVERT_EXTENSION}"
	done

	test -n "${SUDO_USER}" && chown "$SUDO_USER" $FILES
	mv $FILES $DESTINATION
	echo "Done.  Images are in ${DESTINATION}."
}

do_cleanup () {
	#unmount the disk loops
        for ((i=0;i<${#DISKIMGS[@]};i++)); do
                kpartx -dv ${DISKIMGS[$i]}.raw
        done

	for ((i=0;i<${#MOUNTPOINTS[@]};i++)); do
		rm ${MOUNTPOINTS[$i]}.uuid
	done
	for ((i=0;i<${#DISKIMGS[@]};i++)); do
                rm ${DISKIMGS[$i]}.raw 
        done
	cd /
	rm -rf "$WORKINGDIR"
}

cd "$WORKINGDIR"

do_disk_images
do_debootstrap
if [ "$SUITE" = dapper ]
then
    do_fstab_dapper
else
    do_fstab
fi
do_initial_user
do_network_setup
do_bootloader
do_kernel_n_friends 
do_add_remove_packages
do_add_ssh_key
do_exec_script
do_copy_to_disk_images 
do_target_vm_conversion 
do_cleanup

exit 0
